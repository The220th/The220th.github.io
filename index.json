[{"categories":null,"contents":"Содержание\r Сам алгоритм, шифрование, подпись Немного про передачу сообщений Атака на алгоритм   -- Сам алгоритм, шифрование, подпись Скачать/читать  Немного про передачу сообщений Скачать/читать  Атака на алгоритм Скачать/читать  ","permalink":"https://the220th.github.io/guides/math/crypto/el-gamal-encryption/","tags":null,"title":"Асимметричное шифрование. Схема Эль-Гамаля"},{"categories":null,"contents":"Содержание\r Организация честного голосования Прежде чем начинать  Виды голосований  По возможности определения голосующего: По способу голосования Обязательность Способ явки По количеству голосов на голосующего   Ограничения голосов Участники голосования Ещё пару слов   Что такое честное голосование? Традиционное («бумажное») голосование Симметричное шифрование, асимметричное шифрование, цифровая подпись, слепая подпись Простейший протокол Простой протокол Протокол двух агентств Нурми-Саломаа-Сантин Немного про регистратора Протокол на основе ANDOS Протокол Фудзиока-Окамото-Ота Протокол He-Su Подведём небольшой итог Последний штрих Где это ещё может пригодиться? Приложение  Модифицированный протокол Фудзиока-Окамото-Охта     Организация честного голосования Здесь будет описано, что такое честное голосование, и постараемся его организовать.\nПрежде чем начинать Определимся, что такое вообще голосование и как это происходило до сего момента.\nГолосование — способ принятия решения группой людей, при котором общее мнение формулируется путём подсчета голосов членов группы.\nТакже хорошо было бы определиться с тем, какие бывают голосования, кто может голосовать, и кто участвует в голосовании.\nВиды голосований По возможности определения голосующего:   Открытое.\n  Тайное.\n  Открытое:\nЗдесь я думаю понятно. Голосующий открыто всем рассказывает за кого/что голосует.\nТайное:\nС этим не так всё просто. Нужно обеспечить анонимность голосующим по разным причинам (не будем вдаваться в подробности по каким). Тайное голосование практикуют с древних времён. Ещё в Древних Афинах так голосовали при принятии различных решений.\nПо способу голосования Здесь имеется ввиду как именно показать свой голос, можно придумать много вариантов:\n  Жестикуляция. Поднять руку или палец вверх, кивнуть или ещё как-нибудь.\n  Звук. Можно просто назвать претендента.\n  Предметы. Как вариант можно сказать, что камешек \u0026ndash; это претендент 1, а палочка - это претендент 2. Далее складывать это в коробочку, потом считать.\n  Бюллетени. Наверное, это первое, что приходит в голову. \u0026ldquo;Бумажки\u0026rdquo;, на которых делается выбор, потом сдаются.\n  Механические или электромеханические средства. Подойти и нажать кнопку с номером кандидата. Или электрический регистратор голосов Эдисона 1869 год.\n  Электронное. Это, наверное, нас и интересует в первую очередь. Подразумеваются как электронные средства голосования, так и технические электронные средства подсчёта голосов. Сюда включаются, в том числе и перфокарты, где голосующий проделывает дырочку, а дальше какое-нибудь электронное устройство считает голоса. Или ещё вариант поставить галочку на бумаге, которую потом считает сканер. СМС-голосование \u0026ndash; тоже вариант. Но самое интригующее \u0026ndash; это, конечно, интернет голосование.\n  Немного про интернет голосование:\nВ мире набирает обороты практика интернет-голосования на специализированных сайтах или с помощью специального программного обеспечения. Избиратели могут сделать свой выбор не только на избирательных участках, оборудованных компьютерами, но и в любом удобном месте: интернет-кафе, дома или со смартфона. Звучит, конечно, не очень с точки зрения безопасности. Но об этом позже, как раз и нужно добиться в этом материале того, чтобы всё было \u0026ldquo;безопасно\u0026rdquo; и честно.\nВ США первым опытом Интернет-голосования стали предварительные выборы Демократической партии в штате Аризона в марте 2000 г. В феврале 2008 г. было организовано Интернет-голосование на первичных выборах для избирателей-демократов, находящихся за границей.\nНеплохое распространение Интернет-голосование получило в Швейцарии и Эстонии. В швейцарском кантоне Женева для Интернет-голосования на референдумах используются избирательные карточки. Перед голосованием избиратель, предъявив паспорт, может взять в своем почтовом отделении карточку для электронного голосования с уникальным номером и секретным кодом, скрытым под защитным слоем. Далее, на сайте электронного голосования кантона следует ввести номер карточки, поставить галочки напротив нужных вариантов вопросов референдума, затем, убрав с карточки защитный слой, ввести секретный код и получить электронное подтверждение голоса, которое в дальнейшем может быть проверено в администрации кантона. Карточка является одноразовой и перед каждым голосованием за ней надо ходить на почту. В 2005 г. Эстония стала первой страной, предложившей общенациональные выборы местных органов власти через Интернет. В Эстонии для Интернет-голосования вне избирательных участков необходимо с сайта Республиканской избирательной комиссии скачать специальное ПО, а также иметь ID-карту гражданина Эстонии с кардридером, подключаемым к компьютеру, или SIM-карту Mobiil-ID, вставляемую в сотовый телефон. В начале процедуры голосования избиратель проходит двухфакторную аутентификацию (по карте и PIN-коду).\nОбязательность   Добровольное.\n  Обязательное.\n  Можно голосовать по желанию или сделать голосование обязательным. Обязательным по разным причинам, например для увеличения легитимности.\nНа протяжении всей истории встречаются примеры, когда голосование вменялось в обязанность. В ряде полисов Древней Греции существовал закон: если гражданин уклонялся от участия в выборах, то его лишали гражданства и изгоняли, объясняя это решение тем, что полису не нужен гражданин, которому безразлична судьба его государства. Первыми странами, которые посредством законодательного регулирования ввели обязательное голосование, были: Бельгия – в 1892 г., Аргентина – в 1914 г. и Австралия – в 1924 г.\nВ некоторых странах обязательность голосования закреплена на законодательном уровне. Неучастие в голосовании без уважительных причин влечет за собой определенные санкции. Например, штраф, тюремное заключение, частичное или полное лишение гражданских прав, проблемы с работой.\nСпособ явки   Очное. Голосующий приходит и голосует в специальном пункте.\n  Дистанционное. Голосующий никуда не ходит и голосует с любого компьютера.\n  Здесь у кого не спроси, кому не скажи, почти все будут говорить, что невозможно сделать дистанционное голосование честным. Мы попробуем.\nПо количеству голосов на голосующего   Равноправное. «Один голосующий – один голос».\n  Неравноправное. Избиратели изначально находятся в неравных условиях. Часть избирателей оказывается в привилегированном положении по сравнению с другими в силу своего сословного, имущественного, должностного, территориального и т.п. положения.\n  Сюда же можно отнести ситуацию, когда кандидат отражает мнение меньшинства. Поэтому у избирателей может быть несколько голосов. Или ситуация, когда у определённого слоя населения есть дополнительные голоса (Бельгия, собственникам крупного состояния давался доп. голос).\nОграничения голосов Не всех можно допускать к голосованию по разным причинам.\nНапример, если выбирают куда поедут школьники на экскурсию, то голосовать, например, могут только: сами школьники, их родители, сопровождающие и администрация школы. Остальных же это не касается, и эти остальные не должны голосовать.\nИли какие-нибудь выборы в государстве. Тогда ограничения для избирателей и кандидатов могут быть следующих видов:\n  По гражданству. Например, голосуют только граждане.\n  По возрасту. Например, голосуют только с/до определённого возраста.\n  По сроку проживания в государстве. Например, голосуют только те, кто прожил определённое кол-во времени в государстве.\n  По состоянию здоровья. Тут имеется ввиду психическое.\n  По истории гражданина. Например тем, кто привлекался к уголовной ответственности, ограничить голос.\n  По стоимости имущества. Например, ограничить голос тем, у кого имущество стоит меньше, чем определённое кол-во усл. ед.\n  По социальному статусу. Например, разрешить голосовать только определённому классу граждан.\n  По служебному положению. Например, запретить быть избранным военным или священникам.\n  По образованию. Например, голосуют только те, кто умеет читать.\n  По половому признаку.\n  Какие-то ещё ограничения.\n  Участники голосования Попробуем выделить участников:\n  Сами голосующие. То есть те, кто и будет голосовать.\n  Кандидаты/Варианты. Те, за кого голосуют, или то, за что голосуют.\n  Регистратор. Тот, кто определит, кто может голосовать, а кто нет, проконтролирует это, и примет голос.\n  \u0026ldquo;Счётчик\u0026rdquo;. Тот, кто считает голоса.\n  Вопрос только в том, пересекаются ли эти множества?\nЕщё пару слов Что мы поняли? Голосование бывает разное, голосовать могут не все и в голосовании участвуют: голосующие, кандидаты, избирательная комиссия и \u0026ldquo;счётчик\u0026rdquo;.\nТакже нужно бы определиться с самой системой, для чего будем делать честное голосование? Потому что, если говорить про выборы из двух и более кандидатов, то найдутся те, кто скажет, что сама система (демократия) неправильная и нечестная, или те, кто спать не сможет, пока не проголосует. Абстрагируемся. Есть задача, нужно организовать голосование таким образом, чтобы можно было бы гарантировать, что оно будет честное. Чтобы \u0026ldquo;математика\u0026rdquo; гарантировала. А для чего делается система, сейчас не важно.\nЧто такое честное голосование? Что из себя представляет честное голосование? Нужно ввести какие-то критерии, на которые мы будем дальше опираться:\n  Голосовать могут только те, кто имеет право (1)\n  При подсчете результатов голосования для каждого избирателя учитывается не более одного голоса (2)\n  Никто не может узнать, за кого проголосовал конкретный избиратель (3)\n  Никто не может проголосовать за другого (4)\n  Никто не может тайно изменить чей-то голос (5)\n  Голосующий может проверить, что его голос учтён и учтён правильно (6)\n  В случае, если голос зачтён неправильно, голосующий может сообщить об этом (7)\n  Каждый знает кто голосовал, а кто нет (8)\n  Голосующий может изменить свое мнение (9)\n  (3) - этот пункт самый сложный и спорный. И уж тем более не надо говорить, что если голосующих мало, то пункт (3) становится вообще бессмысленным. Также стоит отметить, что он (пункт) хоть как-то снижает продажу голосов. В том смысле, что теперь сложнее доказать, что избиратель проголосовал именно так, а не иначе, тому, кто подкупил голосующего. Но, с другой стороны, всегда можно проголосовать прямо перед скупщиком или ещё как-нибудь. Ещё и пункт (6) даёт возможность голосующему посмотреть на то, как он проголосовал, осталось сделать это перед скупщиком (а потом проголосовать как хочешь, см. пункт (9)). Избавиться от этой проблемы (подкуп голосов) почти нереально, но зато все эти пункты сильно ограничивают тех, кто принимает и считает голоса, что сильно важнее, потому что вреда от этого больше.\n(5) - ключевое слово тайно. Если кто-то что-то изменит, то это станет известно голосующему, и тогда см. пункты (6) и (7)\n(7) - нужно, чтобы ЦИК принимал жалобы. Он может попросту проигнорировать сообщение с ошибкой. Также нужны доказательства того, что голосующий всё сделал верно.\n(8) - пункт может быть нужен для того, чтобы голосующие убедились, что голосовали только легитимные участники.\n(9) - тоже скорее опциональный пункт. Хотя полезен для уменьшения подкупа голосов.\nКлючевой момент ещё в том, что хотелось бы всё это сделать в электронном, дистанционном формате.\nС этим определились, посмотрим на протоколы.\nТрадиционное («бумажное») голосование Происходит это так:\n  Избирательная комиссия формирует списки голосующих и готовит бюллетени. Под формирует имеется ввиду следующее:\n  Публикуется список всех возможных избирателей.\n  Голосующие сообщают, что хотят голосовать (не все же придут из пункта выше).\n  Формируются списки голосующих.\n    В день выборов голосующий приходит на избирательный участок, предъявляет документ, удостоверяющий личность, его регистрируют (проверяют) в списке избирателей, он получает бюллетень, расписывается в его получении. Далее голосует и опускает бюллетень в урну за ширмой.\n  После окончания голосования избирательная комиссия подсчитывает результаты голосования и отсылает результаты в центральную избирательную комиссию (ЦИК).\n  Теперь разберём это поподробнее.\nПункты честного голосования.\nПлюсы, которые, вроде как, должны выполняться:\n  Голосуют только те, кто имеет право. Выполняется (1)\n  Голосующий голосует не более одного раза. Выполняется (2)\n  Соблюдается анонимность. Выполняется (3)\n  Никто не может проголосовать за другого. Выполняется (4)\n  Никто не может тайно изменить чей-то голос. Выполняется (5)\n  Ох как много плюсов! Разберёмся, что не так. Но сперва нужно упомянуть про наблюдателей. Они смотрят, чтобы избирательная комиссия не косячила. Чтобы они не ставили за других галочки, чтобы они не выкидывали бюллетени, чтобы они их правильно запаковали и т. д. Все эти плюсы выше соблюдаются если все честные, сконцентрированные и внимательные. Всегда может пойти что-то не так. Что ж сказать, человеческий фактор, тем не менее может случиться следующее:\n  Члены избирательной комиссии могут проголосовать вместо не пришедших на голосование.\n  Члены избирательной комиссии могут сделать недействительными некоторые бюллетени. Например, разрисовать бюллетень или поставить ещё галочек. То есть можно вычеркивать пункты (4) и (5).\n  Итоги голосования могут быть непреднамеренно неправильно посчитаны.\n  Итоги голосования могут быть преднамеренно неправильно посчитаны.\n  В кабинках за ширмой могут быть скрытые камеры. В теории, можно сказать, что пункт (3) не выполняется.\n  Что ж, почти плюсов не осталось. Хочу отметить, что при организации честного голосования предполагается, что случается самое худшее. Это как при тестировании системы: она должна работать при наихудших событиях. Конечно, избирательная комиссия честная, но хотелось бы составить систему голосования так, чтобы об этом даже не задумываться.\nПерейдём к минусам:\n  Голосующий не может проверить, что его голос учтён. И уж тем более, учтён ли правильно. Один из самых больших минусов. Не выполняется пункт (6), а следом и (7).\n  Долго. Пока дойдёшь до центра, заполнишь бумаги\u0026hellip; Это мелочи. А важно вот что: результаты голосования обрабатываются относительно долго (около нескольких дней).\n  Иногда публикуются списки проголосовавший, а иногда \u0026ndash; нет. Также и пункт (8) может выполняться, а может и нет.\nСмотрим, что ещё есть.\nСимметричное шифрование, асимметричное шифрование, цифровая подпись, слепая подпись Прежде чем начать следующие пункты, нужно разобраться как работает симметричное и асимметричное шифрование.\nПравда с одной оговоркой: шифрование \u0026ndash; это не тема данного исследования, рассматривается именно честное голосование. Поэтому подробно рассказываться, как шифрование работает (и уж тем более доказательства), здесь не будет. Пробежимся кратенько. Если вам нужны подробности, то можете посмотреть здесь или ещё где-нибудь в интернете.\nСимметричное шифрование - алгоритм, который с помощью ключа key может зашифровать сообщение msg с помощью функции encrypt. То есть msg_en = encrypt(msg, key), где msg_en - это зашифрованное сообщение. А потом с помощью того же ключа key может расшифровать сообщение msg_en с помощью функции decrypt, т. е. msg = decrypt(msg_en, key). Ключевой момент, что ключ key для шифрования и дешифрования одинаковый. Мы не будем рассматривать как именно генерируется ключ и как устроены функции encrypt и decrypt. Скажем просто, что будем использовать AES-256. Это один из самых криптостойких на данный момент алгоритм симметричного шифрования. Про AES-256 можно почитать тут.\nПрежде чем двигаться дальше, давайте представим ситуацию: есть Боб и Алиса. Они очень сильно хотят обменяться сообщением с очень важным секретом, причём с таким секретом, что нельзя кому-либо о нём рассказывать. Но есть несколько проблем. Первая - они не способны встретиться лично на улице по разным причинам, поэтому они могут только писать друг другу в интернете. И вторая - они знают, что Ева читает их переписку. На протяжении тысяч лет эта задача была не разрешима, но был изобретён алгоритм Диффи—Хеллмана—Меркла, который решил эту проблему. А потом и ещё многие. С помощью этих алгоритмов Алиса и Боб могут обменяться сообщениями у всех на виду, и Ева не сможет украсть их секрет.\nАсимметричное шифрование - алгоритм, где есть 2 ключа: публичный pubKey и секретный privKey. Публичный ключ рассказывается всем, секретный вообще никому. Сообщение msg шифруется с помощью функции encrypt и публичного ключа, получается зашифрованное сообщение msg_en = encrypt(msg, pubKey). Чтобы расшифровать сообщение, используется функция decrypt и приватный ключ: msg = decrypt(msg_en, privKey). Не будем рассматривать как именно генерируются ключи и как устроены функции encrypt и decrypt. Будем просто использовать алгоритм RSA-4096. Про RSA можно почитать тут.\nТо есть примерно всё так будет: Боб хочет отослать Алисе секрет. Алиса рассказывает всем свой публичный ключ. Боб шифрует сообщение с помощью публичного ключа Алисы, отсылает ей сообщение, которое потом она дешифрует с помощью своего приватного ключа. То есть у каждого собеседника есть свои публичный и приватный ключи. Вот так Алиса и Боб обменялись сообщением, а Ева не смогла прочитать его, хотя она прослушивала канал связи.\nТеперь про цифровую подпись. Здесь тоже используется асимметричное шифрование, тоже есть публичные pubKey и приватные privKey ключи и функции encrypt и decrypt. В чём вообще суть? Есть какой-то документ Document.pdf, и Боб хочет подписать его. Поставить свою \u0026ldquo;подпись\u0026rdquo; так, чтобы можно было бы точно сказать, что он действительно поставил подпись и что, пока документ шёл до Алисы, ни один бит не поменялся в файле. Делается это так. Боб подписывает документ с помощью приватного ключа: signedDocument.pdf = encrypt(Document.pdf, privKey). Далее отсылается signedDocument.pdf Алисе, и та проверяет подпись с помощью публичного ключа Боба: Document.pdf = decrypt(signedDocument.pdf, pubKey). Но теперь функции будут называться по-другому: encrypt \u0026ndash; это sign, а decrypt \u0026ndash; это unsign, да и подписываются не сами документы/файлы, а их хэш. Про подпись для RSA можно почитать тут.\nХэш-функция f(x) = y \u0026ndash; это такая функция, где y посчитать относительно легко, а вот, зная только y, посчитать x почти нереально. y \u0026ndash; это и есть хэш. Причём если x1 и x2 отличаются совсем чуть-чуть (даже хотя бы на 1 бит), то y1 = f(x1) и y2 = f(x2) будут совсем разные. То есть у y1 и y2 будет разное почти \u0026ldquo;всё\u0026rdquo;. Например, f(a123) = abywz и f(a124) = gyizu. Мы будем использовать SHA-256. И ещё, под signedDocument.pdf мы будем подразумевать сам документ и подпись. То есть примерно так: signedDocument.pdf = {Document.pdf, f(Document.pdf)_sig}. Про хэш можно почитать тут.\nНапример, если Document.pdf = aaa, f(Document.pdf) = ngkat, encrypt(ngkat, privKey) = toebl, тоsignedDocument.pdf = {aaa, toebl} = sign(Document.pdf, privKey).\nЕщё осталась слепая подпись. Может потребоваться по разным причинам, чтобы Алиса подписала что-то, не зная, что она подписывает. Например, Боб имеет документ Doc.pdf, который нужно, чтобы подписала Алиса, но сама Алиса не должна знать, что подписывает. Это делается с помощью какого-то числа r, функции blind и публичного ключа Алисы pubKey. Скрываем содержимое документа hiddenDoc.pdf = blind(Doc.pdf, r, pubKey). После Алиса подписывает сообщение с помощью своего приватного ключа privKey: signedHiddenDoc.pdf = sign(hiddenDoc.pdf, privKey), и отсылает обратно Бобу. А Бобу же остаётся снять число r: signedDoc.pdf = unblind(signedHiddenDoc.pdf, r). Вот так Алиса подписала что-то, не зная что. Можно проверить с помощью публичного ключа Алисы pubKey её подпись: Doc.pdf = unsign(signedDoc.pdf, pubKey). Как генерируется число r и как устроены функции blind и unblind, мы рассматривать не будем. Про слепую подпись можно почитать тут.\nЗачем вообще так делать?! Предположим, Алиса \u0026ndash; это человек, который подтверждает личность. Что-то вроде нотариуса. Боб хочет анонимно куда-то послать документ Doc.pdf, но место, куда Боб отсылает Doc.pdf, не принимает документы от кого попало. Скажем что нужно, чтобы документы обязательно отсылали люди, а не боты. Алиса создаёт специально ключи для подтверждения личности и ни для чего больше. Причём, когда она рассказывает всем свой публичный ключ, она уточняет, что он только для заверения личности и что Алиса вообще понятия не имеет, что подписывает. Место, куда Боб собирается отослать Doc.pdf, доверяет Алисе, так как она подписывает документы только реальным людям с паспортами. Вот зачем слепая подпись может понадобиться. Чтобы подтвердить, что Боб \u0026ndash; это человек, а не бот.\nДалее для симметричного шифрования, асимметричного шифрования и подписи будет использоваться эта библиотека: https://github.com/The220th/CipherJavaLib.\nТеперь посмотрим, как это всё применить на алгоритмах голосования. От самого простого к самому соку.\nПростейший протокол Начнём с чего-то попроще. Знакомьтесь, действующие лица: Алиса и Боб\u0026hellip; А если серьёзно, пусть это будут: агентство, проводящее голосование, и голосующие. 2 \u0026ldquo;сущности\u0026rdquo; короче.\nВсё будет происходить так:\n  Агентство составляет списки:\n  Агентство выкладывает списки потенциальных голосующих, тех кому вообще можно голосовать.\n  Голосующие сообщают агентству о желании голосовать. Приходят, например, с паспортом в агентство.\n  После этого агентство выкладывает списки тех, кто голосует.\n    Агентство создаёт ключи: публичный A_pubKey и приватный A_privKey. Публичный рассказывается всем.\n  Голосующий:\n  Голосует, отмечает свой выбор в бюллетене B.\n  С помощью открытого ключа A_pubKey шифрует свой выбор: B_en = encrypt(B, A_pubKey).\n  Отсылает B_en агентству.\n    Агентство:\n  С помощью своего закрытого ключа дешифрует бюллетень B = decrypt(B_en, A_privKey).\n  Считает голоса и публикует.\n    Одно дополнение:\nШаг 1 нужен для определения и объявление числа активных участников. Хотя некоторые из них могут не участвовать, а некоторые и вовсе не существовать («мёртвые души», злонамеренно внесённые агентством), возможность манипулирования голосованием у агентства заметно снижена. Больше это затрагивать не будем.\nПункты честного голосования.\nПлюсы:\n  Простота. Действительно просто реализовать.\n  Никто не может узнать, за кого проголосовал конкретный избиратель. Выполняется (3).\n  Пожалуй, это всё. Теперь минусы:\n  Голосует кто угодно\u0026hellip; Чтобы проголосовать, нужно лишь знать открытый ключ агентства. Агентство в свою очередь не знает откуда пришли бюллетени. Минус (1).\n  Голосовать можно сколько захочешь раз. Минус (2).\n  Агентство вообще никто не контролирует. Оно может манипулировать голосами вообще, как хочет. Минус (4) и (5).\n  Голосующий никак не проверит, что его голос учтён, и как учтён. Минус (6) и (7).\n  Голосующие вообще не вкурсе, кто голосовал, а кто - нет. Минус (8).\n  Про (9), пожалуй, промолчим.\nПротокол никуда не годится. Идём дальше.\nПростой протокол Вообще многих проблем можно было бы избежать в простейшем протоколе, если бы голосующие создавали бы свои публичные и приватные ключи, регистрировали бы их, и подписывали свой выбор. Изменим предыдущий протокол:\n  Голосующий создаёт публичный E_pubKey и приватный E_privKey ключи.\n  Агентство создаёт ключи: публичный A_pubKey и приватный A_privKey. Публичный рассказывается всем.\n  Агентство составляет списки:\n  Агентство выкладывает списки потенциальных голосующих, тех кому вообще можно голосовать.\n  Голосующие сообщают агентству о желании голосовать, заодно регистрируют там E_pubKey. Приходят, например, с паспортом в агентство и показывают свой публичный ключ. То есть теперь агентство знает кому какой ключ принадлежит.\n  После этого агентство выкладывает списки тех, кто голосует.\n    Голосующий:\n  Голосует, отмечает свой выбор в бюллетене B.\n  С помощью своего закрытого ключа E_privKey подписывает бюллетень: B_s = sign(B, E_privKey).\n  Далее B_s шифруется с помощью A_pubKey: B_s_en = encrypt(B_s, A_pubKey).\n  B_s_en отсылается агентству. Тут же он может отослать и свой публичный ключ E_pubKey, чтобы проверять подпись агентству было легче.\n    Агентство:\n  Расшифровывает B_s_en с помощью своего приватного ключа A_privKey: B_s = decrypt(B_s_en, A_privKey).\n  Проверяет подпись: B = unsign(B_s, E_pubKey).\n  Считает голоса и публикует.\n    Пункты честного голосования.\nПлюсы:\n  Простота. Всё ещё просто. Пока что\u0026hellip;\n  Голосовать могут только те, кто имеет право. Выполняется (1).\n  Один голос на голосующего. Выполняется (2).\n  Анонимность ? Остальные голосующие действительно не знают за кого мы проголосовали.\n  В теории мы не можем голосовать за другого, если не знаем его приватный ключ. Выполняется (4).\n  Если голосующий передумал, то можно повторить пункт 4. Агентство же увидит, что он уже голосовал, и поменяет его выбор. Выполняется (9).\n  Теперь минусы:\n  Анонимность не соблюдается. Агентство знает наши \u0026ldquo;паспортные данные\u0026rdquo; и наш выбор. Так что ни о какой анонимности на самом деле речи и не идёт. Минус (3).\n  Агентство по-прежнему никто не контролирует. Они спокойно могут подменять голоса. Минус (5).\n  Голосующий никак не проверит учтён ли вообще его голос, и как учтён. Минус (6) и (7).\n  Голосующие не знают кто голосовал, а кто - нет. Минус (8).\n  Если подвести итог по этому протоколу, то его можно использовать при малом числе голосующих, причём голосующие должны доверять друг другу и агентству. Но мы только начинаем. Следующий.\nПротокол двух агентств Нурми-Саломаа-Сантин Основная идея состоит в том, чтобы заменить одно избирательное агентство двумя, чтобы они контролировали друг друга. А то надоели подменять голоса)\nВводится новый персонаж: Ева\u0026hellip; Регистратор. Тот, кто хотя бы как-то исправит положение. Он будет регистрировать избирателей, подтверждать их личность, а агентство теперь будет счётчиком. Счётчик считает и принимает голоса.\nСам алгоритм:\n  Регистратор составляет списки:\n  Регистратор генерирует уникальные метки {M}.\n  Регистратор выкладывает списки потенциальных голосующих, тех кому вообще можно голосовать.\n  Голосующие сообщают регистратору о желании голосовать. Приходят с документом, удостоверяющий личность, к регистратору.\n  Регистратор выдаёт голосующим уникальную метку M из {M}.\n  После этого Регистратор выкладывает списки тех, кто голосует.\n  Регистратор сообщает по защищённому каналу счётчику все уникальные метки {M}, но без указания кому-какую метку отдали.\n    Голосующий:\n  Делает свой выбор в бюллетене B.\n  Создаёт ключ для симметричного шифрования key (зачем это нужно, будет сказано позже).\n  С помощью секретного ключа key шифрует свою уникальную метку M и бюллетень B в виде единого файла {M, B}_en = encrypt({M, B}, key).\n  Анонимно посылает метку M и {M, B}_en счётчику.\n    Счётчик публикует где-нибудь в открытом доступе M и {M, B}_en.\n  Голосующий после того, как увидит свою метку M и {M, B}_en в открытом доступе (на сайте счётчика например), отправляет счётчику свой ключ для симметричного шифрования key.\n  Счётчик:\n  Дешифрует: {M, B} = decrypt({M, B}_en, key).\n  В дополнение к M и {M, B}_en публикует ещё и {M, B}.\n  Считает, подводит результаты.\n    Фух, этот посложнее. Сделаем пару уточнений:\n  Тут, когда передаются какие-то данные, то они передаются по защищённому каналу. Лень всё это расписывать. То есть у каждого опять есть публичные и приватные ключи, по которым они могут друг-другу шифровать и уже потом отправлять сообщения.\n  Как вы уже, наверное, поняли ключ для симметричного шифрования key создаётся для того, чтобы ни счётчик, ни посторонний не могли до нужного времени узнать содержимое бюллетеня. Плюс ко всему счётчик не сможет отрицать, что не получал бюллетень от голосующих. Благодаря публикации зашифрованного текста и бюллетеня, каждый может проверить, что его голос был учтен должным образом.\n  Теперь про метки {M}. Здесь есть что сказать:\n  Во-первых, метку можно просто угадать. Имеется ввиду такая ситуация: предположим мы тот, кто не голосует. А нам хочется (не спрашивайте почему). Мы начинаем усердно слать счётчику наш бюллетень с рандомными метками. Рано или поздно может быть получится угадать. Поэтому эти метки должны не идти \u0026ldquo;друг за дружкой\u0026rdquo; (1, 2, 3, \u0026hellip;), а быть рандомными на отрезке. Причём чем более длинный отрезок, тем лучше. Например, брать случайно метки с отрезка [10^100; 10^100^10]. Вроде, теперь почти не угадать (попробуйте посчитать вероятность). Или вообще этими метками могут быть длинные строками с рандомными символами.\n  Во-вторых, метки можно и подписать. Пусть регистратор подпишет метки при их создании, тогда вообще не будет никаких проблем. Ведь теперь будет гарантироваться, что именно регистратор дал эти метки, а не случайно угадываются.\n    Ещё немного про ключ key. Его нужно передавать по защищённому каналу. Это нужно, чтобы можно было переголосовать.\n  Чтобы переголосовать необходимо создать новый бюллетень B2, зашифровать и прислать вновь M и {M, B2}_en, но теперь с ключом key, чтобы удостовериться, что это мы раньше голосовали.\n  По окончанию голосования регистратор, может опубликовать, зная кому какая метка принадлежит, и кто проголосовал, список всех проголосовавших. Таким образом будет выполняться (8).\n  Пункты честного голосования.\nПлюсы:\n  Голосовать могут только те, кто имеет право. Выполняется (1).\n  Один голос на одного голосующего. Выполняется (2).\n  Анонимность? Другие избиратели не знают, кто за кого проголосовал.\n  Мы не можем проголосовать за другого. Выполняется (4).\n  Никто не может тайно изменить чей-то голос. Ведь теперь мы видим, что счётчик принял наш голос. Уже никуда не деться всяким там агентствам. Голосующие могут всё доказать. Выполняется (5) и (6). Хотя тут тоже есть одно \u0026ldquo;НО\u0026rdquo;. Но об этом ниже.\n  В случае, если голос зачтён неправильно, голосующий может сообщить об этом. Выполняется (7).\n  Каждый знает кто голосовал, а кто нет. Правда, если регистратор опубликует список всех голосовавших. Тем не менее выполняется (8).\n  Голосующий может изменить свое мнение. Выполняется (9).\n  Минусы:\n  Начнём с главного. Анонимность на самом деле не выполняется. У регистратора есть список всех меток с привязкой к конкретному человеку. Также у регистратора есть информация о том, \u0026ldquo;какая метка\u0026rdquo; за кого/что проголосовала. Сложить 2+2 и теперь регистратор вообще всё знает. Короче, (3) не выполняется. А ведь было так близко. Но это не единственный косяк.\n  Опять-таки приходится кому-то доверять, в данном случае регистратору. Во-первых, он всё про всех знает. Во-вторых, его базу данных могут взломать и выкрасть всё, тогда уже будут все всё знать (хотя это было и в предыдущем протоколе). И, в-третьих, вообще-то никто не мешает счётчику сговориться с регистратором.\n  Если счётчик всё-таки сговорится с регистратором, то тогда счётчику будут известны метки, и он может специально не принимать сообщения от некоторых голосующих.\n  И ещё одна проблема: если регистратор внесёт в список заведомо несуществующих голосующих, то счётчик сможет фальсифицировать бюллетени от них.\n  Немного про регистратора Как видно от регистратора уж слишком много зависит. Во-первых, он по-прежнему уничтожает анонимность (но это мы ещё исправим!). Во-вторых, он может понаделать избирателей столько, сколько ему захочется. Опять приходится кому-то доверять. Никто же не следит за самим регистратором, он может наплодить \u0026ldquo;мёртвых душ\u0026rdquo;, которые будут голосовать как ему угодно. Но, это всё может ловиться межотраслевыми средствами. Если проходят, например, городские выборы, то \u0026ldquo;призрака\u0026rdquo; могут уловить: загс, школы, университеты, военкоматы, кадровые агентства и т. п. Если голосование проходит в какой-нибудь организации, то существуют отдел кадров и начальники, наверняка они что-нибудь заметят. А если голосование в маленькой компании людей, где все друг друга знают, то это вообще не проблема. Ну думаю принцип понятен. Но может всё-таки попробовать придумать что-нибудь такое, что бы вообще заменило регистратора?\nА что, если сами голосующие его заменят? Предположим, мы начальник какого-то коллектива. Весь коллектив мы знаем в лицо. Почему бы нам не подписать их ключи? Можно ещё и подписать ключи друзей, которых хорошо знаем и т. д. В свою очередь наш ключ, тоже подпишут хорошие знакомые и т. д. При этом все публичные ключи выкладываются в открытый доступ. Это всё можно представить в виде графа, где связи \u0026ndash; это подпись одной \u0026ldquo;вершины\u0026rdquo; ключа другой \u0026ldquo;вершины\u0026rdquo;. Теперь, когда счётчику придёт сообщение с голосом избирателя, счётчику нужно посмотреть в открытой базе ключей, что ключ избирателя подписан кем-нибудь, кому счётчик доверяет. А если ещё добавить степень доверия, то граф будет ещё реальнее отражать эту картину. Под степенью доверия имеется вот что: при подписании ключа, мы можем указать насколько сильно, мы доверяем человеку по шкале от 0 до 9 например. Если появятся боты (или обиженные нелегитимные голосующие), которые подписывают друг-другу ключи, то в этом графе появятся некоторые моменты, которые сразу бросаются в глаза. Имеется ввиду вот что. Проанализировав такой граф, можно будет сделать вывод о том, кто нам прислал голос. Но есть способы и обмануть такую систему. Скажем, есть человек, который голосует за себя и за того парня. Имеется ввиду, что у него 2 публичных ключа. Он с помощью социальной инженерии (или, например, за деньги) может попросить кого-нибудь подписать второй ключ. Таким образом у него может быть 2 голоса. Короче, это хорошо, когда сами голосующие поддерживают систему, но нужно быть уверенным, что хотя бы большая часть (процентов 95%) будут честные. Да и вообще нужно каждому в этой системе рассказать, как она работает, и что нужно кому делать, а иначе это всё бессмысленно, потому что можно будет обмануть невежду.\nКороче, приходится выбирать из двух стульев. Всё же сделаем выбор в пользу регистратора. Или регистраторов (их же может быть несколько). Если их много, то ситуация улучшится. Но для простоты будем говорить, что регистратор один. Кому мы можем вообще доверять в этом мире на сегодняшний день? Наверное тому, кому мы доверяем свои денюшки. На данный момент банки могут вас идентифицировать на тех же госуслугах (а это весомый аргумент). Думаю, такой вариант устроит многих.\nПротокол на основе ANDOS Давайте немного забудем про регистратора (хотя, конечно, он ещё вернётся) и посмотрим на такую штуку как ANDOS. Это криптографический протокол «секретной продажи секретов». Продавец имеет список секретов с ответами и выставляет их на продажу. Покупатель желает купить секрет, но не хочет раскрывать какой именно. Протокол гарантирует, что покупатель получит нужный ему секрет и ничего более, в то время как продавец не будет знать, какой именно секрет получил покупатель. Под продавцом здесь имеется ввиду агентство, под покупателями - голосующие, а под секретами и ответами - номера меток и сами метки {M}. Сам протокол сложный, и здесь он не будет описываться, можно о нём почитать в интернете. Главное \u0026ndash; это то, что агентство раздаст метки, но какая кому достанется, никто не узнает.\nПример как может работать ANDOS. Есть оооочень большие числа {M} (ответы). Также есть их порядковые номера {1, 2, 3, ...} (секреты). Всё это генерируется агентством. Потом оно выставляет напоказ все порядковые номера. Голосующие выбирают секрет (порядковый номер). Например, мы выбрали секрет с номером 1291261 и хотим \u0026ldquo;купить\u0026rdquo; ответ. Отрабатывает протокол ANDOS, мы получаем число M с порядковым номером 1291261. Например, M такое. И при этом никто не знает, какой секрет (в данном случае 1291261) мы купили, и что в ответе (то есть в M). А агентство не знает, кто купил какой ответ.\nСам протокол:\n  Агентство составляет списки:\n  Агентство выкладывает списки потенциальных голосующих, тех кому можно голосовать.\n  Голосующие сообщают агентству о желании голосовать. Приходят с паспортом в агентство.\n  После этого агентство выкладывает списки тех, кто голосует.\n    Агентство генерирует набор уникальных меток {M} и с помощью протокола ANDOS распределяет их между голосующими. Как уже было сказано, агентство не может определить принадлежность метки конкретному голосующему.\n  Голосующий:\n  Делает свой выбор в бюллетене B.\n  Создаёт ключ для симметричного шифрования key.\n  С помощью секретного ключа key шифрует свою уникальную метку M и бюллетень B в виде единого файла {M, B}_en = encrypt({M, B}, key).\n  Анонимно посылает метку M и {M, B}_en агентству.\n    Агентство публикует M и {M, B}_en в доказательство избирателю, что голос принят.\n  Голосующий после того, как увидит свою метку M и {M, B}_en, отправляет агентству свой ключ key.\n  Агентство:\n  Дешифрует: {M, B} = decrypt({M, B}_en, key).\n  В дополнение к M и {M, B}_en публикует ещё и {M, B}\n  Считает голоса, подводит результаты\n    Примечания:\n  Когда кто-то обменивается данными, то это происходит по защищённому каналу.\n  Как и в предыдущем протоколе меток должно быть или очень много, или их нужно подписывать. Или и то, и другое.\n  На этапе 2 голосующим в теории может выпасть одна и та же метка. Опять-таки, это можно минимизировать, сделав их очень большое количество. Если это произойдет, то: агентство генерирует новую метку М2, которая не использовалась нигде ранее, выбирает одного из избирателей с коллизией и публикует {M, М2, {M, B}_en}. Голосующий видит, что произошла коллизия. Он заново шифрует уже с новой меткой {M2, B}_en тем же ключом key и отсылает агентству: M2 и {M2, B}_en. Так может сделать только тот, кто до этого отсылал {M, B}_en. Проверить это легко, потому что один и тот же ключ key (известный только \u0026ldquo;правильному\u0026rdquo; голосующему) расшифрует и {M, B}_en, и {M2, B}_en.\n  Если сделать столько же меток {M}, сколько и голосующих, то будет сложнее агентству манипулировать голосованием, но будет много коллизий.\n  Можно и переголосовать. Для этого делаем новый бюллетень B2 и новый ключ key2, посылаем агентству M, старый ключ key и зашифрованное с помощью нового ключа key2 {M, B2}_en2. С помощью секретного ключа key агентство расшифровывает предыдущее шифрованное сообщение, сравнивает метки. В случае совпадения меняет {M, B}_en на {M, B2}_en2. Потом, как увидим, что агентство поменяло, присылаем key2.\n  Пункты честного голосования.\nПлюсы:\n  Чувствуете этот запах? Наконец-то выполняется пункт (3)\n  Ещё соблюдаются (1), (2), (4), (5), (6), (7), (9)\n  Минусы:\n  Мы не можем узнать кто голосовал, а кто - нет. Минус (8)\n  Агентство может голосовать за тех, кто не пришёл голосовать.\n  И, конечно, сам ANDOS. Он сложный и плохо масштабируется. Для большого кол-во голосующих поддерживать его работу будет действительно сложно. Но есть вариант разбивать голосующих на небольшие группы\n  Протокол Фудзиока-Окамото-Ота Здесь опять 3 действующих лица: голосующий, регистратор и счётчик. Сам протокол:\n  Голосующий генерирует ключи для асимметричного шифрования: E_pubKey, E_privKey.\n  Счётчик генерирует ключи: C_pubKey и C_privKey. Публичный ключ рассказывает всем.\n  Регистратор составляет списки:\n  Регистратор генерирует ключи: V_pubKey и V_privKey. Публичный ключ рассказывается всем.\n  Регистратор выкладывает списки потенциальных голосующих, тех кому можно голосовать.\n  Голосующие сообщают регистратору о желании голосовать. Приходят к регистратору и подтверждают личность. Там же регистрируют свой E_pubKey.\n  После этого Регистратор выкладывает списки тех, кто голосует.\n    Голосующий:\n  Генерирует ключ для симметричного шифрования: key.\n  Делает выбор в бюллетене B.\n  Шифрует бюллетень: B_en = encrypt(B, key).\n  Генерируется число r, и с его помощь скрывается содержимое бюллетеня B_en_bl = blind(B_en, r, V_pubKey).\n  Подписывает зашифрованный скрытый бюллетень: B_en_bl_sigE = sign(B_en_bl, E_privKey).\n  Отправляем регистратору B_en_bl_sigE и ещё заодно E_pubKey, чтобы регистратору было проще понять от кого сообщение.\n    Регистратор\n  Принимает сообщение, проверяет, что оно подписано легитимный голосующим (напомним, что голосующие указывали регистратору свои публичные ключи при регистрации): B_en_bl = sign(B_en_bl_sigE, E_pubKey).\n  После того как убедился, что голосующий легальный, подписывает вслепую: B_en_bl_sigV = sign(B_en_bl, V_privKey).\n  Отправляет B_en_bl_sigV голосующему.\n    Голосующий раскрывает бюллетень с помощью числа r: B_en_sigV = unblind(B_en_bl_sigV, r). Вот так регистратор подписал наш бюллетень, не заглядывая туда. Теперь проверить подпись регистратора может любой, в том числе и счётчик. Осталось только ему это отослать.\n  Счётчик:\n  Проверяет, что B_en_sigV действительно подписан регистратором: B_en = unsign(B_en_sigV, V_pubKey).\n  Помещает B_en в специальный список в открытом доступе после оговоренного времени.\n    Голосующий, как увидят, что списки опубликованы, действуют дальше. Находят в этом списке номер их B_en, и отсылают счётчику этот номер и key.\n  Счётчик расшифровывает и подсчитывает результаты.\n  Пункты честного голосования.\nПлюсы:\n Выполняются пункты (1), (2), (3), (4), (5), (6), (7)  Минусы:\n  Мы не знаем кто голосовал. Кто допущен к голосованию - да, а вот кто голосовал - нет. Минус (8)\n  С переголосованием тут всё сложно. Во-первых, нужно модифицировать протокол. Во-вторых, придётся раскрыть личность. Это нужно, чтобы исключить повторное голосование избирателем. Второй то раз регистратор не подпишет уже бюллетень. Нужно будет показать ему ключ. Далее он расскажет счётчику, чтобы предыдущий голос аннулировали. Короче, (9) не выполняется.\n  Давайте, рассмотрим ещё один протокол.\nПротокол He-Su Тут как раньше, но подписывается вслепую не бюллетень, а публичный ключ избирателя:\n  Регистратор генерирует ключи: V_pubKey и V_privKey. Публичный ключ рассказывается всем.\n  Голосующий:\n  Генерирует ключи для асимметричного шифрования: E_pubKey, E_privKey.\n  Скрывает с помощью числа r публичный ключ: E_pubKey_bl = encrypt(E_pubKey, r, V_pubKey).\n    Счётчик генерирует ключи: C_pubKey и C_privKey. Публичный ключ рассказывает всем.\n  Регистратор составляет списки:\n  Регистратор выкладывает списки потенциальных голосующих, тех кому можно голосовать.\n  Голосующие сообщают регистратору о желании голосовать. Приходят к регистратору и подтверждают личность. Там же Регистратор подписывает скрытый ключ: E_pubKey_bl_sigV = sign(E_pubKey_bl, V_privKey).\n  После этого Регистратор выкладывает списки тех, кто голосует.\n    Голосующий:\n  Раскрывает с помощью r подписанный регистратором ключ: E_pubKey_sigV = unblind(E_pubKey_bl_sigV, r). Всё, публичный ключ подписан самим регистратором. Теперь это ключ легитимного голосующего, это может проверить каждый: E_pubKey = unsign(E_pubKey_sigV, V_pubKey). Сам регистратор не знает кому какой ключ подписал. То есть ключ легитимный, а вот чей не сказать.\n  Анонимно отправляет E_pubKey_sigV счётчику.\n    Счётчик:\n  Проверяет, что ключ действительно подписан регистратором: E_pubKey = unsign(E_pubKey_sigV, V_pubKey).\n  Добавляет ключ E_pubKey_sigV в открытый список авторизированных ключей.\n    Голосующий:\n  Генерирует ключ для симметричного шифрования key.\n  Делает выбор в бюллетене B.\n  Шифрует бюллетень: B_en = encrypt(B, key).\n  Подписывает: B_en_sigE = sign(B_en, E_pubKey).\n  Отправляет анонимно счётчику B_en_sigE и E_pubKey_sigV.\n    Счётчик:\n  Проверяет, что E_pubKey_sigV есть в публичном списке авторизированных ключей. Получает E_pubKey = unsign(E_pubKey_sigV, V_pubKey).\n  Проверяет авторизованность ключа: B_en = unsign(B_en_sigE, E_pubKey).\n  Публикует B_en.\n    Голосующий:\n  Видит, что B_en опубликовано.\n  Подписывает ключ: key_sigE = sign(key, E_privKey).\n  Отсылает анонимно счётчику key_sigE и E_pubKey_sigV.\n    Счётчик:\n  Проверяет, что E_pubKey_sigV есть в публичном списке авторизированных ключей. Получает E_pubKey = unsign(E_pubKey_sigV, V_pubKey).\n  Проверяет подпись ключа: key = unsign(key_sigE, E_pubKey).\n  Дешифрует бюллетень: B = decrypt(B_en, key).\n  Публикует B.\n  Подсчитывает результат.\n    Пункты честного голосования.\nПлюсы:\n  Выполняются пункты (1), (2), (3), (4), (5), (6), (7)\n  Можно переголосовать. Надо просто прислать другой бюллетень, подписанный авторизированным ключом. Выполняется (9).\n  Минусы:\n  Снова не знаем кто голосовал. Минус (8).\n  Тут продать голос проще всего. Нужно лишь продать подписанный ключ E_pubKey_sigV.\n  Подведём небольшой итог Почти всё выполняется, но по-прежнему есть возможность продажа голосов. Ещё так и не получилось избежать \u0026ldquo;мёртвых душ\u0026rdquo;. Противостоять этому можно публикацией списка проголосовавших (свойство (8)). Но как раз (8) и не выполняется.\nСравним пока что, что есть:\n   Свойство Традиционный Простейший Простой Два агентства ANDOS Фудзиока-Окамото-Ота He-Su     (1) + - + + + + +   (2) + - + + + + +   (3) +/- + - - + + +   (4) - - + + + + +   (5) - - - + + + +   (6) - - - + + + +   (7) - - - + + + +   (8) +/- - - +/- - - -   (9) - - + + + - +     Какая красота!\nПоследний штрих Во-первых, знать кто проголосовал, а кто \u0026ndash; нет, это один из самых важных пунктов. А он не выполняется. Хотелось бы хоть как-то исправить ситуацию.\nВо-вторых, покупка голосов. На самом деле вред это приносит действительно меньший, чем манипуляция голосами счётчиком. Но по-прежнему неприятно, и, вроде как, это не исправить. Всегда же можно сфотать то, что ты видишь перед собой (когда голосуешь), и показать скупщику.\nВ-третьих, мёртвые души. Регистратор \u0026ndash; это горлышко от бутылки. Нам нужно доверять ему, что не будет лишних. В любом случае список всех тех, кому можно голосовать, публикуется, и можно, в теории, убедиться, что это реальные люди. Также см. эту часть.\nПораскинув мыслишками, можно придумать такой протокол, который бы отвечал всем требованиям (на наш взгляд). Сделаем гибрид всего того, что было до этого и ещё добавим от себя:\n  Счётчик генерирует ключи: C_pubKey и C_privKey. Публичный ключ рассказывает всем.\n  Регистратор составляет списки:\n  Регистратор генерирует ключи: V_pubKey и V_privKey. Публичный ключ рассказывается всем.\n  Регистратор выкладывает списки потенциальных голосующих, тех кому можно голосовать.\n  Голосующие сообщают регистратору о желании голосовать. Приходят к регистратору и подтверждают личность.\n  Регистратор подписывает имя голосующего name: name_sigV = sign(name, V_privKey). Отдаёт голосующему name_sigV.\n  После этого регистратор выкладывает списки тех, кто голосует.\n    Голосующий:\n  Генерирует себе метку M.\n  Скрывает её с помощью числа r: M_bl = blind(M, r, C_pubKey).\n  Генерирует ключ key для симметричного шифрования.\n  Шифрует name_sigV и метку: {name_sigV, M_bl}_en = encrypt({name_sigV, M_bl}, key)\n  Шифрует сообщение для отправки: {name_sigV, M_bl}_en_enC = encrypt({name_sigV, M_bl}_en, C_pubKey).\n  Отсылает анонимно счётчику {name_sigV, M_bl}_en_enC.\n    Счётчик:\n  Получает сообщение и дешифрует: {name_sigV, M_bl}_en = decrypt({name_sigV, M_bl}_en_enC, C_privKey).\n  Публикует {name_sigV, M_bl}_en в специальном списке.\n    Голосующий видит опубликованное {name_sigV, M_bl}_en и:\n  Шифрует ключ для отправки: key_enC = encrypt(key, C_pubKey).\n  Анонимно высылает key_enC.\n    Счётчик:\n  Дешифрует: key = decrypt(key_enC, C_privKey).\n  Дешифрует сообщение голосующего в открытом списке: {name_sigV, M_bl} = decrypt({name_sigV, M_bl}_en, key).\n  Проверяет подпись регистратора: name = unsign(name_sigV, V_pubKey).\n  Подписывает M_bl_sigC = sign(M_bl, C_privKey).\n  Публикует рядом с {name_sigV, M_bl}_en ещё и M_bl_sigC.\n    Голосующий:\n  Видит опубликованное M_bl_sigC и снимает закрывающее число r: M_sigC = unblind(M_bl_sigC, r).\n  Делает выбор в бюллетене B.\n  Генерирует ещё один (другой) ключ для симметричного шифрования key2.\n  Шифрует бюллетень B_en2 = encrypt(B, key2).\n  Генерирует ещё один ключ для симметричного шифрования keyCheck и шифрует: M_enCheck = encrypt(M, keyCheck).\n  Шифрует для отправки: {M_sigC, M_enCheck, B_en2}_enC = encrypt({M_sigC, M_enCheck, B_en2}, C_pubKey).\n  Генерирует число k.\n  Ждёт k сек. Сидит, пьёт чай и/или читает книгу.\n  Отсылает анонимно счётчику {M_sigC, M_enCheck, B_en2}_enC.\n    Счётчик:\n  Принимает сообщение и дешифрует: {M_sigC, M_enCheck, B_en2} = decrypt({M_sigC, M_enCheck, B_en2}_enC, C_privKey).\n  Проверяет свою подпись: M = unsign(M_sigC, C_privKey).\n  Публикует в специальном списке {M, M_enCheck, B_en2}.\n    Голосующий:\n  Видит опубликованное {M, M_enCheck, B_en2} и понимает, что время действовать дальше.\n  Шифрует для отправки: {M, key2}_enC = encrypt({M, key2}, C_pubKey).\n  Отправляет анонимно {M, key2}_enC счётчику.\n    Счётчик:\n  Принимает и дешифрует сообщение: {M, key2} = decrypt({M, key2}_enC, C_privKey).\n  Дешифрует бюллетень: B = decrypt(B_en2, key2).\n  Публикует рядом с {M, M_enCheck, B_en2} ещё и B.\n  Считает голоса и подводит итоги.\n    Дополнения:\n  В алгоритме для шифрования и подписи использовались одни и те же ключи. Так делать не рекомендуется. Здесь это сделано для упрощения усвоения алгоритма.\n  keyCheck нужен, чтобы потом мы могли доказать, что это сообщение отправили мы. По большей части это необходимо для повторного голосования, если совпадут метки M у разных голосующих (см. ниже). Вместо M можно с помощью этого ключа шифровать что угодно, главное, чтобы было с чем сравнить.\n  Забавно, что не понадобились публичные и приватные ключи голосующего. Хотя в теории они могут пригодиться. Каждый раз, когда счётчик публикует в специальном списке информацию \u0026ldquo;для голосующего\u0026rdquo;, то её можно шифровать публичным ключом избирателя. Тогда и избиратель должен всё время отсылать свой публичный ключ, когда он высылает анонимно сообщение счётчику. Проблема только в том, что нужно генерировать отдельно ключи для подачи списка имён и отдельно для подачи бюллетеня. Иначе не будет выполняться пункт (3).\n  Под name в шаге 2 имеется ввиду ФИО, год рождения, ID\u0026hellip; Короче то, что может единственным образом идентифицировать человека. Или можно сказать строчка, соотносящаяся с голосующим, из списка тех, кто голосует. Причём должно быть написано, что используется \u0026ldquo;только для этого голосования\u0026rdquo;.\n  Шифрование {name_sigV, M_bl} в шаге 3 нужно для того, чтобы счётчик не знал до нужной поры, от кого принял сообщение. А то вдруг ему не хочется, чтобы Вася не голосовал. На шаге 4 {name_sigV, M_bl}_en публикуется и уже нельзя сказать, что сообщение не принимал.\n  На шаге 5 Голосующий отправляет вместе с key_enC счётчику ещё и номер своего {name_sigV, M_bl}_en в публичном специальном списке.\n  На шаге 7 ждать k секунд необходимо, чтобы нельзя было связать между собой список с именами и список с бюллетенями. Вот что имеется ввиду. Пусть Вася прислал своё name, получил подпись метки M_sigC, а потом сразу же отсылает свой голос {M_sigC, M_enCheck, B_en2}_enC. Очевидно, что бюллетень B_en2 прислал name, то есть Вася.\n  Теперь есть список тех, кто проголосовал. Между шагами 2 и 3 может пройти действительно много времени. Избиратель может просто забыть про голосование или ему станет лень, или вдруг мировоззрение поменяется, и он откажется голосовать, или просто никак (например, избиратель уехал на дачу). Поэтому тот список, который публикует регистратор не отражает число проголосовавших. А вот пункты 3 и 9 выполняются почти в одно время. Причём программой. Для голосования нужно какое-нибудь вычислительное устройство и интернет. В любом случае появляется возможность ещё ближе подойти к правильному кол-ву проголосовавших, ведь бюллетеней должно быть не больше, чем name. Плюс ко всему это ещё больше ограничивает счётчика.\n  Ждать k сек может оказаться действительно неудобно на первый взгляд. Но программа для голосования может работать в фоне после шага 7, как демон на GNU\\Linux, или как сервис на Windows, или как фоновое приложение на Android. Сейчас такой мир, что на фоне работает много всяких приложений, хотим мы того или нет. Главное, чтобы они были с открытым исходным кодом. Приходится голосующим идти на компромисс, но зато списки проголосовавших будут очень близкими к действительности.\n  Голосующий на шаге 5 должен понимать, что если он в дальнейшем не проголосует, то за него в теории может проголосовать счётчик. Но возможна и такая ситуация. Например, 10 голосующих, они все выполнили 5-ый шаг. 9 уже проголосовало, а последний не голосует почему-то. Счётчик думает, что 10-ый вообще не собирается дальше участвовать, и голосует за него. Теперь все 10 голосов из 10-ти опубликованы. И тут просыпается тот самый 10-ый голосующий и ловит счётчика на лжи, показывая подписанную счётчиком метку M_sigC.\n  Опять-таки регистратора должны контролировать неравнодушные (а такие найдутся), которые будут следить за списком голосующих (чтобы не было \u0026ldquo;мёртвых душ\u0026rdquo;) и которые будут делать у себя копии этих публичных специальных списков. Как говорится: \u0026ldquo;Если что-то один раз попало в интернет, то остаётся там навсегда\u0026rdquo;.\n  Может сложиться такая ситуация, что метки M могут совпасть у разных избирателей. Маловероятно (если генерировать метки в большом диапазоне), но могут. Тогда:\n  Счётчик выбирает одного из избирателей, у которых коллизия, и публикует рядом с {M, M_enCheck, B_en2} рандомно сгенерированную метку M2, которая ещё нигде не использовалась.\n  Когда избиратель увидит это, он генерирует новый ключ keyCheck2, шифрует им M2_enCheck2 и присылает счётчику {M2, M2_enCheck2, keyCheck, B_en2}.\n  Счётчик принимает сообщение и проверяет: M == decrypt(M_enCheck, keyCheck).\n  Заменяет {M, M_enCheck, B_en2} на {M2, M2_enCheck2, B_en2}. Причём содержимое бюллетеня счётчик так и не узнал ещё. Содержимое раскроется, когда голосующий пришлёт key2.\n    Если нужно переголосовать:\n  Напомним, что сейчас опубликовано {M, M_enCheck, B_en2} или {M, M_enCheck, B_en2} вместе с B\n  Голосующий генерирует новый ключ key3 и делает новый бюллетень B2. Шифрует его B2_en3.\n  Голосующий генерирует новый ключ keyCheck2, шифрует им M_enCheck2 и присылает счётчику {M, M_enCheck2, keyCheck, B2_en3}.\n  Счётчик принимает сообщение и проверяет: M == decrypt(M_enCheck, keyCheck).\n  Заменяет {M, M_enCheck, B_en2} на {M, M_enCheck2, B2_en3}. И, если рядом был прикреплён ещё и бюллетень B, то удаляет его.\n    Пункты честного голосования.\nПлюсы:\n Выполняются вообще все пункты. Даже (8). Хотя, конечно, может сложиться ситуация, когда он не на 100% будет отражать истину. Можно рядом с пунктом (8) поставить хотя бы +/-.  Минусы:\n  Возможно, алгоритм перемудрён, и можно сделать ещё лучше и проще.\n  Более уязвим к DoS-атакам.\n  Этот алгоритм как раз и будет реализовываться. Здесь можно найти саму программу и исходники.\nТакже, надеюсь, кто-нибудь дальше разовьёт идею с децентрализованным регистратором. Это наверняка можно сделать как-нибудь. Например, с помощью Blockchain.\nГде это ещё может пригодиться? Наверное первое, что приходит в голову - это опрос. Скажем, есть начальник, который хочет узнать, что думают другие о нём. Но подчинённые не хотят высказывать своё мнение, потому что боятся за это получить по шапке. Чтобы реализовать алгоритм для решения этой ситуации, нужно вместо бюллетеня отсылать \u0026ldquo;счётчику\u0026rdquo; текст со своим мнением о начальнике. В данном случае начальник и счётчик - это может быть одна и та же сущность.\nИли представим, например, такую ситуацию: есть участники какого-то соревнования, агентство и оценивающие. Участники приходят к оценивающим, выполняют какое-то действие, которое оценивают оценивающие. Они же и выставляют участнику какой-то балл. Потом на основании этого балла агентство выбирает лучших. И вот сама задача. Нужно опубликовать баллы участников таким образом, что:\n  Участники точно знали, что опубликовали их баллы правильно.\n  Результаты участников не должны знать посторонние наблюдатели. Это те, кто мониторит список, но не являются участниками. Или сами участники не должны знать результаты друг друга. То есть баллы публикуются, а кому какой балл принадлежит узнать нельзя.\n  Таких задач можно придумать много. Или можно добавлять какие-нибудь ещё требования. Например, такое: участники не могут посмотреть баллы других, пока не закончится соревнование. Или такое: участники должны знать имена всех тех, кто вообще принимает участие в соревновании.\nВ данной ситуации оценивающие могут принадлежать агентству (работать там), и поэтому они действительно заинтересованы в выборке лучших. Плюс ко всему участники могут наблюдать друг за другом, смотреть что баллы верно выставлены оценивающими. При этом им не обязательно знать всех по именам или в лицо.\nВот что имеется ввиду. Например, агентству нужны те, кто дальше всех кидает телефоны. Устраиваются соревнования по бросанию телефонов на дальность. Участники приходят к агентству, регистрируются и через какое-то время в объявленный день приходят на соревнование. Участники друг друга не знают. Конечно, они могут познакомиться, но это не критично в данной ситуации. Главное то, чтобы оценивающие правильно выставили количество метров броска, и чтобы они выставляли результаты \u0026ldquo;физическим\u0026rdquo; людям. Участники один за другим подходят к оценивающим, кидают телефон как можно дальше, а оценивающие считают метры броска, выставляют кол-во баллов и публикуют. Тот, кто только что бросил, делает что-то, чтобы результат был учтен верно. Все остальные участники тоже видели, на сколько метров он бросил телефон, и убедились, что результаты проставлены верно.\nВ итоге участники не знают кто бросил телефон, но знают, что такой участник действительно был, и что его результат засчитан правильно. Как-то это всё звучит неадекватно\u0026hellip;\nАлгоритм, который тут приведён наверняка можно сделать лучше, на его придумывание почти совсем не было времени. Но тем не менее вот он:\n  Участник создаёт публичный P_pubKey и приватный P_privKey ключи.\n  Оценивающий создаёт публичный E_pubKey и приватный E_privKey ключи. Публичный рассказывается всем.\n  Участники сообщают агентству о желании участвовать, заодно регистрируют там свой P_pubKey. Приходят, например, с паспортом в агентство и показывают свой публичный ключ. То есть теперь агентство знает кому какой ключ принадлежит.\n  Агентство приходит к оценивающему и просит провести соревнование. Здесь же агентство ему передаёт все публичные ключи людей, которые участвуют в соревновании.\n  Участник приходит на соревнование, показывает свой публичный ключ P_pubKey оценивающему, выполняет что-то и получает за это балл b, который выставляет оценивающий.\n  Оценивающий подписывает этот балл b_sigE = sign(b, E_privKey) и публикует в открытом списке {P_pubKey, b_sigE}. Проверить подпись могут все: b = unsign(b_sigE, E_pubKey).\n  Участник подписывает балл b_sigP = sign(b, P_privKey), если согласен с результатами. Показывает b_sigP оценивающему.\n  Оценивающий проверяет подпись b = unsign(b_sigP, P_pubKey) и подписывает b_sigP_sigE = sign(b_sigP, E_privKey). Рядом с {P_pubKey, b_sigE} публикует ещё и b_sigP_sigE.\n  Агентство сортирует список по баллам, смотрит лучших, и связывается с ними, так как оно знает кому какой ключ принадлежит.\n  Примечания:\n  Оценивающим и агентством может быть одна и та же сущность.\n  b может представлять из себя не только балл, а ещё заметку о том, кому именно он поставлен (какому ключу). Например, участник с публичным ключом HW25KAj6L3j6a получил 57 баллов, тогда b = HW25KAj6L3j6a:57. Это хорошо тем, что теперь все подписи оценивающего b_sigE будут разные. Также теперь проверить подпись участника будет проще, не нужно искать его ключ агентству в шаге 9, он уже записан в b.\n  В шаге 5 показать оценивающему публичный ключ нужно для того, чтобы подтвердить, что участник соревнования легитимный.\n  В шаге 6 другие участники соревнования увидят опубликованный балл и сравнят с тем, что они насчитали.\n  В шаге 7 участник подписывает свои баллы, как знак того, что балл выставлен правильно. Агентство же потом на шаге 9 может проверить подписи участников.\n  В шаге 8 участник увидит, что b_sigP_sigE в открытом доступе. Значит, его результаты засчитаны.\n  Шаг 9 может провести кто угодно (имеется ввиду отсортировать список). Таким образом участник может узнать на каком он месте в соревновании.\n  Вся эта процедура (подпись, проверка подписи, показ публичного ключа) может проводиться с помощью программы на каком-нибудь портативном устройстве.\n  Опять-таки нужно кому-то доверять. Оценивающего, например, участники не всегда могут контролировать, наблюдая со стороны. Может сложиться такая ситуация, что к оценивающему придёт сын маминой подруги и получит куча баллов.\n  Главная проблема: участник может подкупить кого-нибудь, кто может получить много баллов, чтобы тот выступил за него.\n  Приложение Уже после написания нашлось ещё кое-что.\nМодифицированный протокол Фудзиока-Окамото-Охта Изначальный протокол не очень-то удобный. Чуть изменим:\n  Голосующий генерирует ключи для асимметричного шифрования: E_pubKey, E_privKey.\n  Счётчик генерирует ключи: C_pubKey и C_privKey. Публичный ключ рассказывает всем.\n  Регистратор составляет списки:\n  Регистратор генерирует ключи: V_pubKey и V_privKey. Публичный ключ рассказывается всем.\n  Регистратор выкладывает списки потенциальных голосующих, тех кому можно голосовать.\n  Голосующие сообщают регистратору о желании голосовать. Приходят к регистратору и подтверждают личность. Там же регистрируют свой E_pubKey.\n  После этого регистратор выкладывает списки тех, кто голосует.\n    Голосующий:\n  Генерирует ключ для симметричного шифрования: key.\n  Делает выбор в бюллетене B.\n  Шифрует бюллетень: B_en = encrypt(B, key).\n  Генерируется число r, и с его помощь скрывается содержимое бюллетеня B_en_bl = encrypt(B_en, r, V_pubKey).\n  Подписывает зашифрованный скрытый бюллетень: B_en_bl_sigE = sign(B_en_bl, E_privKey).\n  Шифруем сообщение для того, чтобы отправить регистратору: B_en_bl_sigE_enV = encrypt(B_en_bl_sigE, V_pubKey).\n  Отправляем регистратору B_en_bl_sigE_enV и ещё заодно E_pubKey, чтобы регистратору было проще понять от кого сообщение.\n    Регистратор\n  Принимает сообщение от голосующего и дешифрует: B_en_bl_sigE = decrypt(B_en_bl_sigE_enV, V_privKey).\n  Проверяет, что оно подписано легитимный голосующим (напомним, что голосующие указывали регистратору свои публичные ключи при регистрации): B_en_bl = sign(B_en_bl_sigE, E_pubKey).\n  После того как убедился, что голосующий легальный, подписывает вслепую: B_en_bl_sigV = sign(B_en_bl, V_privKey).\n  Шифрует сообщение для того, чтобы отправить обратно голосующему: B_en_bl_sigV_enE = encrypt(B_en_bl_sigV, E_pubKey).\n  Отправляет B_en_bl_sigV_enE голосующему.\n    Голосующий:\n  Принимает и дешифрует сообщение: B_en_bl_sigV = decrypt(B_en_bl_sigV_enE, E_privKey).\n  Раскрывает бюллетень с помощью числа r: B_en_sigV = unblind(B_en_bl_sigV, r).\n  Генерируем себе метку M.\n  Шифруем сообщение для счётчика: {M, B_en_sigV}_enC = encrypt({M, B_en_sigV}, C_pubKey).\n  Анонимно отсылает счётчику {M, B_en_sigV}_enC.\n    Счётчик:\n  Дешифрует сообщение: {M, B_en_sigV} = decrypt({M, B_en_sigV}_enC, C_privKey).\n  Проверяет подпись регистратора: B_en == unsign(B_en_sigV, V_pubKey).\n  Публикует M и B_en_sigV.\n    Голосующий, когда увидит, что M и B_en_sigV опубликованы:\n  Шифрует свой ключ: key_enC = encrypt(key, C_pubKey).\n  Анонимно высылает счётчику key_enC.\n    Счётчик:\n  Дешифрует сообщение: key = decrypt(key_enC, C_privKey).\n  Расшифровывает бюллетень: B == decrypt(B_en, key).\n  В дополнение к {M, B_en_sigV} публикует {M, B}\n    Счётчик считает и подводит итоги.\n  ","permalink":"https://the220th.github.io/guides/math/crypto/correct-vote/","tags":null,"title":"Организация честного голосования"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","permalink":"https://the220th.github.io/search/","tags":null,"title":"Поиск"},{"categories":null,"contents":"Чтобы увеличить привлекательность смартфонов, производители ставят на них как можно больше разных программ. Это понятно. Просто берём и удаляем ненужное… Стоп.\nОказывается, некоторые программы невозможно удалить. Например, на отдельных моделях Samsung невозможно удалить Facebook (есть только опция \u0026lsquo;disable\u0026rsquo;, в итоге будет просто место занимать). Говорят, на Samsung S9 вдобавок предустановлены «неудаляемые» приложения Microsoft.\nВсё это надо зачистить.\nВпрочем, «неудаляемые» они только теоретически. На практике достаточно открыть ADB (Android Debug Bridge) и запустить пару команд.\nНа телефоне должна быть разрешена отладка по USB (семь тапов но номеру сборки в настройках и включаем её в новом пункте меню), а на компьютере установлен USB-драйвер устройства.\nТеперь приступаем.\npm list packages | grep '\u0026lt;OEM/Carrier/App Name\u0026gt;'\nвыводит список установленных пакетов.\npm list packages | grep \u0026#39;oneplus\u0026#39; package:com.oneplus.calculator package:net.oneplus.weather package:com.oneplus.skin package:com.oneplus.soundrecorder package:com.oneplus.opsocialnetworkhub package:cn.oneplus.photos package:com.oneplus.screenshot package:com.oneplus.deskclock package:com.oneplus.setupwizard package:com.oneplus.sdcardservice package:com.oneplus.security package:cn.oneplus.nvbackup package:com.oneplus.wifiapsettings Как вариант, можно установить на телефоне бесплатную программу Инспектор приложений. Она покажет подробную информацию обо всех установленных приложениях, их разрешения. Вдобавок она может извлекать (скачивать) APK-файлы для любого установленного приложения.\nДля удаления конкретного пакета запускаем такую команду:\npm uninstall -k --user 0 \u0026lt;name of package\u0026gt;\nЭто работает без рутования.\nДля упомянутых в начале статьи «неудаляемых» программ это выглядит так:\nFacebook\npm uninstall -k –user 0 com.facebook.katana\nFacebook App Installer\npm uninstall -k –user 0 com.facebook.appmanager\nMicrosoft OneDrive\npm uninstall -k –user 0 com.microsoft.skydrive\nMicrosoft PowerPoint\npm uninstall -k –user 0 com.microsoft.office.powerpoint\nMicrosoft OneNote\npm uninstall -k –user 0 com.microsoft.office.onenote\n… и так далее.\n","permalink":"https://the220th.github.io/guides/miscellaneous/android-remove-preinstalled/","tags":null,"title":"Удаление предустановленных приложений на Android"},{"categories":null,"contents":"Электронный документ из 100+ страниц? Сложно читать с экрана?\nЭтот гайд поможет эффективно распечатать этот документ, чтобы было удобно читать. В итоге должна получится \u0026ldquo;книга\u0026rdquo; (брошура)\nГайд только для Windows:\nСкачиваем и устанавливаем priPrinter (магнит) Запускаем ворд с этим документом В ворде тыкаем печать и выбираем виртульный принтер priPrinter В открывшимся окне справа сверху выбрать принтер \u0026ldquo;Microsoft Print to PDF\u0026rdquo; Бырать сверху между \u0026ldquo;Темы\u0026rdquo; и \u0026ldquo;Двустороння печать\u0026rdquo; в ОбычнаяF6 \u0026ldquo;БрошураF7\u0026rdquo; или просто нажать F7 В верхнем левом углу тыкнуть на печать Под \u0026ldquo;Копии: 1\u0026rdquo; нажать \u0026ldquo;Свойства Принтера\u0026hellip;\u0026rdquo; -\u0026gt; Двусторонняя печать -\u0026gt; Переставить флажок на \u0026ldquo;Принтер поддерживает двустороннюю печать\u0026rdquo; -\u0026gt; нажать ОК Тыкнуть на печать. Done  Теперь получился PDFник (или можно сразу на печать отдать, если в третьем пункте выбрать сразу ваш принтер), где нечётные страницы - это первая сторона листа, а чётные - это вторая сторона листа. Теперь останется только правильно распечатать и сложить их\n","permalink":"https://the220th.github.io/guides/miscellaneous/brochure-printing/","tags":null,"title":"Печать брошюрой"},{"categories":null,"contents":"Software Reporter Tool - это \u0026ldquo;антивирус\u0026rdquo; от Google, сканирует файлы (причём не понятно по какому принципу, сканирует всё крч), делает отчёт и отправляет домой. Естественно это СИЛЬНО нагружает ЖД и CPU, и не понятно, когда включается (обычно сразу после установки Chrome или в самый не подходящий момент).\nВот способ, как отключить эту парашу:\n Переходим сюда: C:\\Users[Пользователь]\\AppData\\Local\\Google\\Chrome\\User Data\\SwReporter[Версия] [удаление всего, что вы видите не поможет, потому что Chrome скачает всё заново при следующем обновлении, поэтому:] ПКМ на папке \u0026ldquo;SwReporter\u0026rdquo; и свойства, далее в \u0026ldquo;безопасность\u0026rdquo;, тыкаем дополнительно (снизу справа) Нажать на \u0026ldquo;Отключение наследования\u0026rdquo;, после на \u0026ldquo;Удалить все унаследованные разрешения из этого объекта\u0026rdquo;, соглашаемся на всё (даже не надо читать) Везде нажать OK (2 раза). И всё  ","permalink":"https://the220th.github.io/guides/miscellaneous/software-reporting-tool/","tags":null,"title":"Software Reporting Tool и 100% CPU"},{"categories":null,"contents":"Шпаргалка по Markdown (перевод, оригинал)\nПоиграть с разметкой Markdown можно на демо-странице.\nСодержание Заголовки\nВыделение\nСписки\nСсылки\nИзображения\nПодсветка кода и синтаксиса\nТаблицы\nЦитаты\nВстроенный HTML\nГоризонтальная линия\nНовая строка\nВидео Youtube\nЗаголовки\n# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 Кроме того, H1 и H2 можно обозначить подчеркиванием: Alt-H1 ====== Alt-H2 ------ H1 H2 H3 H4 H5 H6 Кроме того, заголовки H1 и H2 можно обозначить подчеркиванием:\nAlt-H1 Alt-H2 Выделение\nКурсив обозначается *звездочками* или _подчеркиванием_. Полужирный шрифт - двойными **звездочками** или __подчеркиванием__. Комбинированное выделение **звездочками и _подчеркиванием_**. Для зачеркнутого текста используются две тильды . ~~Уберите это.~~ Курсив обозначается звездочками или подчеркиванием.\nПолужирный шрифт - двойными звездочками или подчеркиванием.\nКомбинированное выделение звездочками и подчеркиванием.\nДля зачеркнутого текста используются две тильды . Уберите это.\nСписки\n(В данном примере предшествующие и завершающие пробелы обозначены точками: ⋅)\n1. Первый пункт нумерованного списка 2. Второй пункт ⋅⋅*Ненумерованный вложенный список. 1. Сами числа не имеют значения, лишь бы это были цифры ⋅⋅1. Нумерованный вложенный список 4. И еще один пункт. ⋅⋅⋅Внутри пунктов списка можно вставить абзацы с таким же отступом. Обратите внимание на пустую строку выше и на пробелы в начале (нужен по меньшей мере один, но здесь мы добавили три, чтобы также выровнять необработанный Markdown). ⋅⋅⋅Чтобы вставить разрыв строки, но не начинать новый параграф, нужно добавить два пробела перед новой строкой.⋅⋅ ⋅⋅⋅Этот текст начинается с новой строки, но находится в том же абзаце.⋅⋅ ⋅⋅⋅(В некоторых обработчиках, например на Github, пробелы в начале новой строки не нужны.) * Ненумерованный список можно размечать звездочками - Или минусами + Или плюсами  Первый пункт нумерованного списка Второй пункт   Ненумерованный вложенный список.    Сами числа не имеют значения, лишь бы это были цифры\n  Нумерованный вложенный список\n  И еще один пункт.\nВнутри пунктов списка можно вставить абзацы с таким же отступом. Обратите внимание на пустую строку выше и на пробелы в начале (нужен по меньшей мере один, но здесь мы добавили три, чтобы также выровнять необработанный Markdown).\nЧтобы вставить разрыв строки, но не начинать новый параграф, нужно добавить два пробела перед новой строкой. Эта текст начинается с новой строки, но находится в том же абзаце. (В некоторых обработчиках, например на Github, пробелы в начале новой строки не нужны.)\n   Ненумерованный список можно размечать звездочками   Или минусами   Или плюсами  Ссылки\nСсылки можно оформить разными способами.\n[Обычная ссылка в строке](https://www.google.com) [Обычная ссылка с title](https://www.google.com \u0026#34;Сайт Google\u0026#34;) [Ссылка со сноской][Произвольный регистронезависимый текст] [Относительная ссылка на документ](../blob/master/LICENSE) [Для ссылок со сноской можно использовать цифры][1] Или можно просто вставить ссылку в квадратные скобки [текст ссылки] Произвольный текст, после которого можно привести ссылки. [произвольный регистронезависимый текст]: https://www.mozilla.org [1]: http://slashdot.org [текст ссылки]: http://www.reddit.com Обычная ссылка в строке\nОбычная ссылка с title\nСсылка со сноской *\nОтносительная ссылка на документ\nДля ссылок со сноской можно использовать цифры\nИли можно просто вставить ссылку в квадратные скобки текст ссылки\nПроизвольный текст, после которого можно привести ссылки.\n(*) Для символов не входящих в ASCII, например кириллицы, текст сноски все-таки регистрозависим (прим. перев.)\nИзображения\nВот наш логотип (наведите указатель, чтобы увидеть текст заголовка): Внутри строки: ![alt-текст](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \u0026#34;Текст заголовка логотипа 1\u0026#34;) В сноске: ![alt-текст][logo] [logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \u0026#34;Текст заголовка логотипа 2\u0026#34; Вот наш логотип (наведите указатель, чтобы увидеть текст заголовка):\nВнутри строки:\nВ сноске:\nКод и подсветка синтаксиса\nБлоки кода являются частью функций Markdown, но не подсветка синтаксиса. Однако многие обработчики, например Github или Markdown Here, поддерживают подсветку синтаксиса. Список поддерживаемых языков и способ их указания может различаться. Markdown Here поддерживает десятки языков (и не-языков, например синтаксис diff и заголовки HTTP); полный список и способ указания языков см. на странице highlight.js demo-странице.\n`Код` в строке обрамляется `обратными апострофами`. Код в строке обрамляется обратными апострофами.\nБлоки кода выделяются либо тремя обратными апострофами ``` либо четырьмя пробелами в каждой строке. Рекомендуется использовать три апострофа \u0026ndash; они проще и только они поддерживают подсветку синтаксиса.\n```javascript var s = \"Подсветка JavaScript\"; alert(s); ``` ```python s = \"Подсветка Python\" print s ``` ``` Язык не указан, синтаксис не подсвечен. Но мы вставим в него \u0026lt;b\u0026gt;тег\u0026lt;/b\u0026gt;. ```  var s = \u0026#34;Подсветка JavaScript\u0026#34;; alert(s); s = \u0026#34;Подсветка Python\u0026#34; print s Язык не указан, синтаксис не подсвечен (некоторые обработчики все же подсвечивают). Но мы вставим в него \u0026lt;b\u0026gt;тег\u0026lt;/b\u0026gt;. Таблицы\nТаблицы не являются частью Markdown, но многие обработчики, например Markdown Here и Github, поддерживают их. Они позволяют легко добавить таблицы в электронное письмо \u0026ndash; в других случаях для этого нужно копировать их из другого приложения.\nВертикальные линии обозначают столбцы. | Таблицы | Это | Круто | | ------------- |:------------------:| -----:| | столбец 3 | выровнен вправо | $1600 | | столбец 2 | выровнен по центру | $12 | | зебра-строки | прикольные | $1 | Внешние вертикальные линии (|) не обязательны и нужны только, чтобы сам код Markdown выглядел красиво. Тот же код можно записать так: Markdown | не такой | красивый --- | --- | --- *Но выводится* | `так же` | **клево** 1 | 2 | 3 Вертикальные линии обозначают столбцы.\n   Таблицы Это Круто     столбец 3 выровнен вправо $1600   столбец 2 выровнен по центру $12   зебра-строки прикольные $1    Внешние вертикальные линии (|) не обязательны и нужны только, чтобы сам код Markdown выглядел красиво. Тот же код можно записать так:\n   Markdown не такой красивый     Но выводится так же клево   1 2 3    Цитаты\n\u0026gt; С помощью цитат очень удобно в письме обозначать исходный текст. \u0026gt; Эта строка - часть той же цитаты. Разрыв цитаты. \u0026gt; Это очень длинная строка, но она будет правильно процитирована даже при размещении на нескольких строках. Продолжаем писать, чтобы эта строка не вмещалась на одной строке в любом окне. Кстати, в цитаты можно *вставлять* даже **Markdown**.  С помощью цитат очень удобно в письме обозначать исходный текст. Эта строка - часть той же цитаты.\n Разрыв цитаты.\n Это очень длинная строка, но она будет правильно процитирована даже при размещении на нескольких строках. Продолжаем писать, чтобы эта строка не вмещалась на одной строке в любом окне. Кстати, в цитаты можно также размечать с помощью Markdown.\n Встроенный HTML\nЧасто Markdown понимает чистый HTML.\n\u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;Список определений\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Это то, что люди иногда используют.\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;Markdown внутри HTML\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Работает *не очень** хорошо. Используйте HTML-\u0026lt;em\u0026gt;теги\u0026lt;/em\u0026gt;.\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt;  Список определений Это то, что люди иногда используют. Markdown внутри HTML Работает *не очень** хорошо. Используйте HTML-теги.  Горизонтальные линии\nТри и более... --- Дефисы *** Звездочки ___ Подчеркивания Три и более\u0026hellip;\n Дефисы\n Звездочки\n Подчеркивания\nНовая строка\nДля понимания работы разрыва строка автор главным образом рекомендует экспериментировать и пробовать \u0026ndash; нажмите \u0026lt;Enter\u0026gt; один раз (т.е. перейдите на новую строку), потом нажмите дважды (т.е. вставьте две новые строки) и посмотрите что приозошло. Вы сразу поймете что вам нужно. В расширении Markdown Here для браузеров есть удобная функция \u0026ldquo;Markdown Toggle\u0026rdquo;, которая поможет в этом.\nПримечание переводчика:\nДля переноса на новую строку в конце предыдущей строки необходимо добавить два пробела. Без этого большинство парсеров Markdown не выполняют переход на новую строку.\nПопробуйте ввести следующее:\nЭто начальная строка Эта строка отделена от предыдущей двумя новыми строками и станет *отдельным абзацем*. Это тоже отдельный абзац, но...⋅⋅ Эта строка отделена одной новой строкой, поэтому она находится в *том же абзаце*. Это начальная строка\nЭта строка отделена от предыдущей двумя новыми строками и станет отдельным абзацем.\nЭто тоже отдельный абзац, но\u0026hellip;[здесь два пробела]\nЭта строка отделена одной новой строкой, поэтому она находится в том же абзаце.\n(Примечание: В Markdown Here разрывы строк ведут себя так же, как в GFM, поэтому не нужно вставлять по две новые строки.)\nВидео Youtube\nРолики нельзя вставить напрямую, но можно вставить изображение со ссылкой на видео, например:\n\u0026lt;a href=\u0026#34;http://www.youtube.com/watch?feature=player_embedded\u0026amp;v=ID_ВИДЕОРОЛИКА_НА_YOUTUBE\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;http://img.youtube.com/vi/ID_ВИДЕОРОЛИКА_НА_YOUTUBE/0.jpg\u0026#34; alt=\u0026#34;ALT-ТЕКСТ ИЗОБРАЖЕНИЯ\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;180\u0026#34; border=\u0026#34;10\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt; На чистом Markdown, но без размеров изображения и рамки:\n[![ALT-ТЕКСТ ИЗОБРАЖЕНИЯ](http://img.youtube.com/vi/ID_ВИДЕОРОЛИКА_НА_YOUTUBE/0.jpg)](http://www.youtube.com/watch?v=ID_ВИДЕОРОЛИКА_НА_YOUTUBE) ","permalink":"https://the220th.github.io/guides/miscellaneous/markdown-cheat-sheet/","tags":null,"title":"Markdown Cheat Sheet"},{"categories":null,"contents":"Vanced - это модификация официального YouTube клиента на Android, в котором вырезана вся реклама и включено фоновое воспроизведение.\nТакже есть встроенная поддержка SponsorBlock.\nЗагрузить здесь.\n","permalink":"https://the220th.github.io/resources/vanced/","tags":null,"title":"Vanced - 'правильная' модификация YouTube клиента на Android"},{"categories":null,"contents":"Уверен, что вы очень часто сталкиваетесь с рекламой внутри видео на YouTube, которую вставил человек, записавший видеозапись. Для таких случаев существует данное браузерное расширение.\nSponsorBlock блокирует интегрированные рекламные сегменты внутри видеоролика. Информация о них, однако, краудсорсится от других пользователей расширения, которые вручную их помечают.\nЗагрузить здесь.\n","permalink":"https://the220th.github.io/resources/sponsorblock/","tags":null,"title":"SponsorBlock - блокировка интегрированной YouTube рекламы"},{"categories":null,"contents":"Самый лучший блокировщик рекламы для браузера. Поддерживает огромный перечень списков фильтров, имеет приятный интерфейс и богатый функционал.\nЗагрузить для Firefox. (большая совместимость)\nЗагрузить для Chrome.\nТакже рекомендую поставить данный скрипт, чтобы блокировать больше рекламы.\n","permalink":"https://the220th.github.io/resources/ublock/","tags":null,"title":"Ublock Origin - самый лучший блокировщик рекламы"},{"categories":null,"contents":"Небольшая программа, которая при помощи технологии UPnP позволяет на время \u0026ldquo;открыть\u0026rdquo; порт на вашем роутере. В некоторых \u0026ldquo;экзотических\u0026rdquo; конфигурациях сети провайдера (предположительно у Ростелекома), позволяет открыть порты даже на сером IP адресе. Загрузить здесь.\n","permalink":"https://the220th.github.io/resources/portmapper/","tags":null,"title":"Portmapper - открываем порты через UPnP"},{"categories":null,"contents":"Если у вас windows 8 и выше, то отойдя на мин 5-8 можно услышать как ваш HHD надрывается, шумит и кричит о помощи. Но как только тронуть мышкой, то всё прекращается.\nВирус? Нет (да), это автоматическая дефрагментация. Конечно, дефрагментация - это хорошо. Но нельзя ли её включать, когда этого хочет сам пользователь. Процесс, отвечающий за это безобразие - это svchost.exe (defragsvc). Чтобы выключить:\n Нажать win + r Ввести туда dfrgui (здесь же можно провести дефрагментация ваших жёсткий дисков вручную) Нажать внизу \u0026ldquo;Изменить параметры\u0026rdquo; Убрать галочку \u0026ldquo;Выполнять по расписанию (рекомендуется)\u0026rdquo; Нажать ОК и всё.  Говорят, что эта херня работает и для SSD, что вообще недопустимо (да и зачем вообще). Так что если у вас SSD, то это необходимо выключить\n","permalink":"https://the220th.github.io/guides/miscellaneous/disable-autodefrag/","tags":null,"title":"Выключаем дефрагментацию в простое"},{"categories":null,"contents":"После покупки флешек на ali нужно их всегда проверять. Недобросовестные продавцы будут указывать объём больше, чем он есть на самом деле (хотя система будет показывать, что всё ОК). Они это делают (во всяком один из способов), форматируя флешки на низком уровне. Можно на них нажиться, вернуть деньги и оставить флешку, просто реального объёма.\nКак вставили флешку запускайте h2testw, выбирайте English, после выберите флэшку в Select target, тыкните all available space и снимите галочку, если стоит, в endless verify. Теперь просто нажать Write+Verify и ждать. Долго ждать.\nЕсли всё хорошо, то будет типа такого вывода:\nTest finished without errors. You can now delete the test files *.h2w or verify them again. Writing speed: 6.41 MByte/s Reading speed: 21.2 MByte/s H2testw v1.4 Если же нет, то может быть такая надпись:\nThe media is likely to be defective. 58.5 GByte OK (122845070 sectors) 57 KByte DATA LOST (114 sectors) Details:0 KByte overwritten (0 sectors) 0 KByte slightly changed (\u0026lt; 8 bit/sector, 0 sectors) 57 KByte corrupted (114 sectors) 0 KByte aliased memory (0 sectors) First error at offset: 0x0000000171279c00 Expected: 0x0000000171279c00 Found: 0xcea8a293915717a4 H2testw version 1.3 Writing speed: 17.9 MByte/s Reading speed: 95.0 MByte/s H2testw v1.4 или такое\nWarning: Only 4052 of 4091 MByte tested. The media is likely to be defective. 3.9 GByte OK (8252480 sectors) 22.4 MByte DATA LOST (46016 sectors) Details:2 MByte overwritten (4096 sectors) 0 KByte slightly changed ( 8 bit/sector, 0 sectors) 20.4 MByte corrupted (41920 sectors) 2 MByte aliased memory (4096 sectors) First error at offset: 0x00000000005f6000 Expected: 0x00000000005f6000 Found: 0xa91360744cd56eb3 H2testw version 1.3 Writing speed: 10.2 MByte/s Reading speed: 26.6 MByte/s H2testw v1.4 В любом случае окошко станет красно, уже понятно, что что-то не так.\nПишите продавцу, чтобы возвращал деньги. Нужен скрин программы h2testw; фотография (видео), где видно, что проверяемая флешка воткнута в usb порт, нет никаких других. Также на фотографии (видео) должно быть видно вывод программы h2testw (обоих окон) и окно винды, где показана буква вашей флешки. Пусть возвращает деньги, оставляя флешку вам. Если отказывается, то поднимайте спор на уровень выше. Ведь такие флешки несут угрозу вашим данным. Если при записи на флешку исчерпывается её реальный объём, то начинаются затираться ваши файлы. Это не дело.\nТеперь решение проблемы. В строке \u0026ldquo;\u0026hellip; GByte OK (xxx sectors)\u0026rdquo; копируем кол-во этих самых xxx секторов, запускаем программу MyDiskFix-ENG и вбиваем в Sectors: во второе окошко эти xxx секторов (32 не трогаем!). Тыкаем Low-Level, выбираем в Choose Device: нужную флешку и жмём START Format. Может всплыть окошко, но там просто нажимаем ок или типа того. Везде в выводе программы должны стоять ...OK!. Объём, конечно, уменьшится, но он станет хотя бы правильным.\n","permalink":"https://the220th.github.io/guides/miscellaneous/check-usb-disk/","tags":null,"title":"Проверка флешек на обьём"},{"categories":null,"contents":"Даже с \u0026ldquo;правильной\u0026rdquo; виндой обновления не исключаются. Отсюда скачать и запустить программу.\nВ версии v4.0.0 - Declutter: В третьей вкладке \u0026ldquo;Pause Updates\u0026rdquo; поставить \u0026ldquo;Number of days to defer updates\u0026rdquo; на 99999 ВЕЗДЕ и нажать save.\nА вообще в services (службы) надо выключить \u0026ldquo;Центр обновления Windows\u0026rdquo; и \u0026ldquo;Фоновая интеллектуальная служба передачи (BITS)\u0026rdquo; прямо насовсем.\n","permalink":"https://the220th.github.io/guides/miscellaneous/disable-win10-updates/","tags":null,"title":"Отключаем обновления Windows 10"},{"categories":null,"contents":"Bandizip - на удивление приятный архиватор для Windows, с поддержкой Drag\u0026rsquo;n\u0026rsquo;Drop и просто приятным интерфейсом.\nПосле какого-то обновления засланцы добавили рекламу. Вполне подойдёт Bandizip версии 6.26 Build 27128. Там её не должно быть.\nЗагрузить: magnet:?xt=urn:btih:7e45d992716cecbc966a3f3838864352b1cd7cff\u0026amp;tr=http%3A%2F%2Fbt02.nnm-club.cc%3A2710%2F009460e9ce6f9636115f16c25150d177%2Fannounce\u0026amp;tr=http%3A%2F%2F%5B2001%3A470%3A25%3A482%3A%3A2%5D%3A2710%2F009460e9ce6f9636115f16c25150d177%2Fannounce\nИли кликабельная\nPS: рекомендуется выключить проверку обновления после установки в первом пункте меню.\n","permalink":"https://the220th.github.io/resources/bandizip/","tags":null,"title":"Bandizip - альтернатиный архиватор для Windows"},{"categories":null,"contents":"Содержание\r Введение Узлы Чебышёва Оценка погрешности Код   Введение Возможно всё было так: Чебышёв нашёл крутой многочлен n-ой степени: $T_n = cos(n \\cdot arccos(x))$\nНазвали его многочленом Чебышева. Выглядит как не многочлен, но это именно он. Немного подумав можно прийти к такому выводу:\n$$\\cos((n+1) \\cdot \\arccos(x)) = 2 \\cdot \\cos(\\arccos(x)) \\cdot \\cos(n \\cdot \\arccos(x)) - \\cos((n-1) \\cdot \\arccos(x))$$\n$$\\cos((n+1) \\cdot \\arccos(x)) = 2 \\cdot x \\cdot \\cos(n \\cdot \\arccos(x)) - \\cos((n-1) \\cdot \\arccos(x))$$\n$$T_{n+1} = 2 \\cdot x \\cdot T_n - T_{n-1}$$\nВсё равно не похоже на многочлен\u0026hellip;\nВоспользуемся этой формулой в явном виде:\n$$T_0 = \\cos(0 \\cdot \\arccos(x)) = 1$$\n$$T_1 = \\cos(1 \\cdot \\arccos(x)) = x$$\n$$T_2 = 2 \\cdot x \\cdot T_1 - T_0 = 2x^2 - 1$$\n$$T_3 = 2 \\cdot x \\cdot T_2 - T_1 = 4x^3 - 3x$$\n$$T_4 = 2 \\cdot x \\cdot T_3 - T_2 = 8x^4 - 8x^2 + 1$$\n$$T_5 = 2 \\cdot x \\cdot T_4 - T_3 = 16x^5 - 20x^3 + 5x$$\n$$\u0026hellip;$$\nТеперь видно, что именно многочлены. Проверьте, например так:\n$$T_5(3.2) = \\cos(5 \\cdot \\arccos(3.2)) = 4729.35\u0026hellip;$$\n$$T_5(3.2) = 16 \\cdot (3.2)^5 - 20 \\cdot (3.2)^3 + 5 \\cdot (3.2) = 4729.35\u0026hellip;$$\nЗачем всё это? Есть очень крутая особенность у этих многочленов:\n  На промежутке [-1, 1]: $\\max_{[-1, 1]}(T_n) = 1$, $\\min_{[-1, 1]}(T_n) = -1$\n  Старший коэф. перед $x^n$ равен $2^{(n-1)}$\n  Давайте нормализируем многочлен:\nПусть $T^*_n = \\frac{T_n}{2^{(n-1)} }$\nЗачем нужен $T^*_n$? У него есть ещё более крутые особенности:\n  На промежутке [-1, 1]: $\\max_{[-1, 1]}(T^*_n) = \\frac{1}{ 2^{(n-1)} }$, $\\min_{[-1, 1]}(T^*_n) = -\\frac{1}{ 2^{(n-1)} }$\n  Старший коэф. перед $x^n$ равен 1\n  1-ая особенность особенно значимая\nУзлы Чебышёва Теперь нужно найти корни этого многочлена:\n$$T^*_n = 0$$\n$$\\frac{\\cos(n \\cdot \\arccos(x))}{2^{(n-1)}} = 0$$\n$$\\cos(n \\cdot \\arccos(x)) = 0$$\n$$n \\cdot \\arccos(x) = \\frac{\\pi}{2} + \\pi \\cdot k$$\n$$\\arccos(x) = \\frac{\\pi}{2 \\cdot n} + \\frac{\\pi \\cdot k}{n}$$\n$$x = \\cos(\\frac{pi}{2 \\cdot n} + \\frac{\\pi \\cdot k}{n})$$\n$$x_k = \\cos( \\frac{ (2 \\cdot k + 1) \\cdot \\pi }{2 \\cdot n} )$$, k = 0, 1, 2, \u0026hellip;, n-1\nЗамечу: Тут именно от 0 до n-1. Т. е. кол-во узлов = n шт\nТ. е. $T^*_n = \\frac{1}{2^{(n-1)}} \\cdot (x-x_0) \\cdot (x-x_1) \\cdot \u0026hellip;$\nНаходим на отрезке от [-1, 1] узлы $x_k$:\n$$x_1 = \\cos( \\frac{ (2 \\cdot 0 + 1) \\cdot \\pi }{2 \\cdot n} )$$\n$$x_2 = \\cos( \\frac{ (2 \\cdot 1 + 1) \\cdot \\pi }{2 \\cdot n} )$$\n$$\u0026hellip;$$\nИ этим иксам [$x_1$, $x_2$, \u0026hellip;] соответствуют игреки [$y_1=f(x_1)$, $y_2=f(x_2)$, \u0026hellip;]. Всё, можно интерполировать\nПочему именно так? Помните оценку погрешности интерполяционных многочленов?\nОценка погрешности $\\max_{[-1, 1]}(|f(x)-L_n(x)|) \\leq \\frac{M_{n+1}} {(n+1)!} \\cdot \\max_{[-1,1]}(|\\omega_n(x)|)$, где $M_{n+1}=\\max_{[-1,1]}(\\frac{d^{(n+1)}f}{dx^{(n+1)}})$\nТо есть производная (n+1)-го порядка $f^{(n+1)}_x$\nЧто такое $\\omega_n$? Это и есть $T^*_{n+1}$\nПомните его max и min из особенности 1? $\\max_{[-1,1]}(|\\omega_n|) = \\max_{[-1,1]}(|T^*_{n+1}|) = \\frac{1}{ 2^n }$. Т. е. оооооочень маленькое число уже хотя бы при n=5\nТ.е. $$\\max_{[-1, 1]}{(|f(x)-L_n(x)|)} \\leq \\frac{M_{n+1}}{(n+1)!} \\cdot \\frac{1}{2^n}$$\nНо это ведь на отрезке [-1, 1]. Кому это нужно? Ну перенесём на наш отрезок [a, b] (аффинное преобразование):\n$$x_k = \\frac{1}{2} \\cdot ((b-a) \\cdot \\cos( \\frac{(2 \\cdot k + 1) \\cdot \\pi}{2 \\cdot n + 2} ) + b + a)$$, k = 0, 1, \u0026hellip;, n\nВывод этой формулы - это путь ниндзя, и поэтому каждый его должен пройти сам, если, конечно, есть желание\u0026hellip;\n$$T^*_n = \\frac{1}{2^{n-1}} \\cdot (x-x_0) \\cdot (x-x_1) \\cdot \u0026hellip;$$\nА что там с погрешностью? Это тоже путь ниндзя, но вот формула:\n$$\\max_{[a,b]}(|w_n(x)|) = \\frac{(b-a)^{(n+1)}}{2^{(2 \\cdot n+1)}}$$\nТ.е. погрешность:\n$$\\max_{[a, b]}(|f(x)-L_n(x)|) \\leq \\frac{M_{n+1}}{(n+1)!} \\cdot \\frac{(b-a)^{(n+1)}}{2^{(2 \\cdot n+1)}}$$\nгде $$M_{n+1}=\\max_{[a,b]}(\\frac{d^{(n+1)}f}{dx^{(n+1)}})$$\nГлавное помнить, что n - это степень многочлена, а не количество узлов\nКод Что мы хотим вообще? Хотим функцию findChebyshevNodes(), которая бы просто вернула \u0026ldquo;массив\u0026rdquo; правильных \u0026ldquo;иксов\u0026rdquo;. Код будет на matlab, как бы сильно не хотелось обратного:\n% a - левая граница % b - правая граница % n - кол-во \u0026#34;иксов\u0026#34; (узлов) functionres =findChebyshevNodes(a, b, n)n = n-1; % потому что в формуле используется степень многочлена, которая на 1 меньше кол-ва узлов res = zeros(1, n+1); for i = 1:(n+1) res(i) = (1/2)*((b-a)*cos( ((2*(i-1)+1)*pi)/(2*n+2) ) + b + a); end и заодно высчитать максимальную погрешность:\n%max[a, b](|f(x)-L_n(x)|) \u0026lt;= (M_{n+1} / (n+1)!)*( (b-a)^(n+1) / (2^(2*n+1)) ), где M_{n+1}=max[a,b](d^(n+1)f/dx^(n+1)) %Здесь n - это степень многочлена, а не кол-во точек (их на 1 больше) functionres =findChebyshevDefect(n_dots)n = n_dots; a = 1; b = 71; res = ((здесь M_{n+1}) / factorial(n))*( (b-a)^n / (2^(2*n-1)) ); Дальше, зная \u0026ldquo;иксы\u0026rdquo;=X, найдём \u0026ldquo;игреки\u0026rdquo;=Y и подставим в какую-нибудь фукцию, которая делает интерполяцию.\n","permalink":"https://the220th.github.io/guides/math/numericalmethods/chebyshev-mnogochlen/","tags":null,"title":"Многочлен Чебышева"},{"categories":null,"contents":"Содержание\r Шаг первый: Установка Шаг полтора: Если на удалённой машине Шаг второй: Тестовая Java программа Бонус: Подключение через SSH  Вариант 1: Всё ручками Вариант 2: Мы же используем java, так ведь?   Шаг третий: Hibernate pizza time   Шаг первый: Установка Гайд предназначен, чтобы именно подключить MySQL, hibernate, и, возможно, jsch с нуля. Но это не руководство, как пользоваться этим вот всем. Постараюсь объяснять всё по ходу текста, но, встречая незнакомые слова, пробуйте их \u0026ldquo;загуглить\u0026rdquo;. Возможно на изучение этого гайда уйдёт не один час. Как СУБД будем использовать MySQL. Установка будет производиться на xubuntu 20.04 TLS, но для Windows тоже подойдёт. Надо просто сразу переходить к шагу 2, но узнать, как устанавливать MySQL на Windows, придётся самому.\n\u0026gt; sudo apt update \u0026gt; sudo apt install mysql-server mysql-client \u0026gt; mysql -V В моём случае вывод такой: mysql Ver 14.14 Distrib 5.7.33, for Linux (x86_64) using EditLine wrapper. Т. е. MySQL версии 14.14\n\u0026gt; sudo systemctl status mysql \u0026gt; sudo mysql_secure_installation На первом шаге настраивается плагин валидации пароля. Чтобы его включить нажмите Y, или его можно не включать. Затем надо задать сложность пароля, который позволит установить этот плагин. Здесь 0 означает слабый пароль, а 2 - сложный. Когда плагин будет настроен введите пароль root (root для СУБД, а не системы) и подтвердите, что хотите использовать именно его. Введите Y для отключения анонимного доступа к MySQL, затем ещё раз Y, чтобы запретить подключаться к базе от имени root удаленно. Снова Y, чтобы удалить тестовую базу данных. Затем, обновите привилегии для пользователей. После завершения настройки вы можете подключиться пользователем root к серверу баз данных из командной строки. По умолчанию ваши созданные БД находятся в /var/lib/mysql/\n\u0026gt; sudo mysql -u root Теперь создадим пользователя, тестовые БД и таблицу.\n-- Создание БД CREATEDATABASEtestDB;usetestDB;--Создание таблицы books CREATETABLE`books`(`id`int(11)NOTNULL,`name`varchar(50)NOTNULL,`author`varchar(50)NOTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=latin1;--Заполним таблицу какими-нибудь данными INSERTINTOtestDB.books(id,`name`,author)VALUES(1,\u0026#39;Core Java, Volume I\u0026#39;,\u0026#39;Key Horstmann\u0026#39;);INSERTINTOtestDB.books(id,`name`,author)VALUES(2,\u0026#39;The Code Book\u0026#39;,\u0026#39;Simon Singh\u0026#39;);-- Создадим пользователя. Запомните его имя и пароль, нам они ещё пригодятся CREATEUSER\u0026#39;testUser\u0026#39;@\u0026#39;ip\u0026#39;IDENTIFIEDBY\u0026#39;superUser.password2281337\u0026#39;;-- удаление пользователя: DROP USER \u0026#39;testUser\u0026#39;@\u0026#39;ip\u0026#39;; -- вместо ip нужно вписать ваш белый ip или localhost. Если не указать @\u0026#39;ip\u0026#39;, то будет @\u0026#39;%\u0026#39;, это означает, что всё разрешено -- Дадим созданному пользователю доступ к созданной БД GRANTALLPRIVILEGESONtestDB.*TO\u0026#39;testUser\u0026#39;@\u0026#39;ip\u0026#39;;FLUSHPRIVILEGES;-- Посмотрим, что всё получилось SELECTuser,hostFROMmysql.user;SHOWGRANTSFOR\u0026#39;testUser\u0026#39;@\u0026#39;ip\u0026#39;;exit;Зайдём от имени созданного пользователя.\n\u0026gt; mysql -u testUser -p [-h \u0026#39;ip\u0026#39;] [введите пароль]\n-- Посмотрим, что имеем доступ к нашей таблице с книгами. SELECTid,name,authorFROMtestDB.books;-- Убедимся, что используется порт 3306 showvariableslike\u0026#39;port\u0026#39;;-- по умолчанию должен быть именно порт 3306 quit;Шаг полтора: Если на удалённой машине Пару слов: Соединение с базой данных MySQL по умолчанию БЕЗ ШИФРОВАНИЯ. Возможно 4 варианта (скорее всего больше) решения этой проблемы:\n Шифровать всё в самой программе Java Подключить и настроить MySQL SSL Использовать VPN И, наверное, самый разумный: подключаться к БД через SSH. Но тогда переходите сразу к соответствующему шагу  По умолчанию подключиться к СУБД можно только из localhost. Исправляем:\n  В конфигурации /etc/mysql/mysql.conf.d/mysqld.cnf находим \u0026quot;bind-address = 127.0.0.1\u0026quot;. Меняем его на \u0026quot;bind-address = 0.0.0.0\u0026quot;.\n  Перезапускаем сервис:\n  \u0026gt; sudo systemctl restart mysql Убеждаемся, что всё работает:  sudo ss -tulpn | grep mysql Шаг второй: Тестовая Java программа JDBC - это стандарт взаимодействия Java с СУБД, API. Можно сказать, что это интерфейс, который потом должны реализовывать.\nmysql-connector - это \u0026ldquo;драйвер\u0026rdquo; для коннекта к СУБД. Или штука, которая реализовывает интерфейс JDBC. Это нужно, чтобы подключаться к СУБД MySQL.\nЭто на пальцах и не формально, всё сложнее)\nНе путайте с JPA. Подробнее про это лучше почитать тут: https://habr.com/ru/post/265061/, или поищите в интернете: \u0026ldquo;orm, jpa и jdbc\u0026rdquo;\n Находим где-нибудь mysql-connector-java-x.x.xx.jar. Например так:  Перейдите на сайт: https://downloads.mysql.com/archives/c-j/\nВыбираем Platform Independent и скачиваем zip или tar archive. Там и будет mysql-connector-java-x.x.xx.jar (вместо x.x.xx должны быть циферки). В моём случае - это mysql-connector-java-8.0.23.jar\n Закидываем JAR-файл в директорию, содержащуюся в CLASSPATH. Например, в корень проекта. Но лучше создать папку ./lib/ и закинуть туда, потом укажем Java, где его искать (в пункте 4).\n  Создадим файл JavaToMySQL.java. Пробуем написать программу:\n  import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class JavaToMySQL { // JDBC URL, username and password of MySQL server  // Обратите внимание на [ip]. Укажите ваш белый ip или localhost  private static final String url = \u0026#34;jdbc:mysql://[ip]:3306/testDB\u0026#34;; // Помните, мы делали пользователя. Здесь его login и password  private static final String user = \u0026#34;testUser\u0026#34;; private static final String password = \u0026#34;superUser.password2281337\u0026#34;; // JDBC variables for opening and managing connection  private static Connection con; private static Statement stmt; private static ResultSet rs; public static void main(String args[]) { // Сам запрос к СУБД  String query = \u0026#34;select count(*) from books\u0026#34;; try { // opening database connection to MySQL server  con = DriverManager.getConnection(url, user, password); // getting Statement object to execute query  stmt = con.createStatement(); // executing SELECT query  rs = stmt.executeQuery(query); while (rs.next()) { int count = rs.getInt(1); System.out.println(\u0026#34;Total number of books in the table : \u0026#34; + count); } } catch (SQLException sqlEx) { sqlEx.printStackTrace(); } finally { //Знаю, лучше использовать оператор try с ресурсами, чтобы не делать всего этого. Здесь так шакально, чтобы показать, что нужно это вот всё вообще-то закрывать.  //close connection ,stmt and resultset here  try { con.close(); } catch(SQLException se) { /*can\u0026#39;t do anything */ } try { stmt.close(); } catch(SQLException se) { /*can\u0026#39;t do anything */ } try { rs.close(); } catch(SQLException se) { /*can\u0026#39;t do anything */ } } } } Самое интересное. Компиляция с драйвером и запуск. Начальные условия:  Мы находимся в папке .\nJavaToMySQL.java находится в папке .\nmysql-connector-java-x.x.xx.jar находится в ./lib/\nТогда компиляция:\n\u0026gt; javac -encoding utf-8 -cp .:./lib/mysql-connector-java-x.x.xx.jar JavaToMySQL.java Вместо x.x.xx должны быть циферки. Флаг -encoding utf-8 означает, что раскодировать исходники компилятору нужно с помощью utf-8, -cp ... показывает компилятору, где искать классы и jar-ники. И теперь запуск:\n\u0026gt; java -cp .:./lib/mysql-connector-java-x.x.xx.jar JavaToMySQL Должно вывести: \u0026quot;Total number of books in the table : 2\u0026quot;\nЕсли нет, то проверьте, что вы правильно ввели все данные для подключения к СУБД, что вы правильно указали все jar-ники, что вы используйте одинаковые версии java и javac. Может быть файл mysql-connector-java-x.x.xx.jar загрузился битым или неполностью, проверьте это. Если это всё не помогло, то подождите, пока не пройдёт полнолуние, и попробуйте снова.\nСледующим шагом подключимся к СУБД с помощью SSH. Если вам это не нужно, то сразу переходите к следующему шагу\nБонус: Подключение через SSH Как было уже сказано, убедитесь, что в /etc/mysql/mysql.conf.d/mysqld.cnf написано именно \u0026quot;bind-address = 127.0.0.1\u0026quot;, а не \u0026quot;bind-address = 0.0.0.0\u0026quot;.\nВариант 1: Всё ручками Итак ситуация следующая. Имеем сервер с белым IP serverIP, где настроен SQL сервер на порте 3306. Если у вас Windows 7 или ниже, то используйте puttySSH или переходите сразу к следующему пункту\nВводим команду, чтобы открыть SSH туннель:\n\u0026gt; ssh -fN -L 1234:localhost:3306 username@serverIP или если вы используете ключи (ssh-keygen)\n\u0026gt; ssh -L 1234:localhost:3306 username@serverIP \u0026amp; Теперь нужно в программе подключаться к порту 1234, а не 3306.\nЗатем всё что необходимо поменять в JavaToMySQL.java - это строку в коде:\nprivate static final String url = \u0026#34;jdbc:mysql://[ip]:3306/testDB\u0026#34;; на\nprivate static final String url = \u0026#34;jdbc:mysql://localhost:1234/testDB\u0026#34;; Если хотим \u0026ldquo;уничтожить\u0026rdquo; SSG туннель:\n\u0026gt; ps aux | grep 1234 Найдите там PID нашего процесса, что-то похожее на это:\nthe220th 13427 0.0 0.0 14612 732 ? Ss [время] 0:00 ssh -fN -L 1234:localhost:3306 username@serverIP В данной ситуации нужное нам число — это 13427\nУничтожаем:\n\u0026gt; kill 13427 #(если не поможет, то: sudo kill -9 13427) Вариант 2: Мы же используем java, так ведь? Чтобы сделать то же самое с Java, вы можете использовать JSch. В гайде будет jsch-0.1.55.jar. Сейчас ситуация та же, что и в 4-ом пункте на шаге два, но в ./lib/ будет ещё лежать jsch-0.1.55.jar.\nМодифицируем программу. Создадим UpdateMySqlDatabase.java\nЧто изменилось:\nДобавилась функция: makeTunnelSSH() и поменялся порт в строке: private static final String url = \u0026quot;jdbc:mysql://[ip]:1234/testDB\u0026quot;; (было 3306)\nimport java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import com.jcraft.jsch.JSch; import com.jcraft.jsch.Session; /** * Simple Java program to connect to MySQL database running on localhost and * running SELECT and INSERT query to retrieve and add data. * @author Javin Paul */ public class UpdateMySqlDatabase { // JDBC URL, username and password of MySQL server  private static final String url = \u0026#34;jdbc:mysql://[ip]:1234/testDB\u0026#34;; private static final String user = \u0026#34;testUser\u0026#34;; private static final String password = \u0026#34;superUser.password2281337\u0026#34;; // JDBC variables for opening and managing connection  private static Connection con; private static Statement stmt; private static ResultSet rs; private static Session session; private static int lport; private static String rhost; private static int rport; public static void main(String args[]) { makeTunnelSSH(); String query = \u0026#34;select count(*) from books\u0026#34;; try { // opening database connection to MySQL server  con = DriverManager.getConnection(url, user, password); // getting Statement object to execute query  stmt = con.createStatement(); // executing SELECT query  rs = stmt.executeQuery(query); while (rs.next()) { int count = rs.getInt(1); System.out.println(\u0026#34;Total number of books in the table : \u0026#34; + count); } } catch (SQLException sqlEx) { sqlEx.printStackTrace(); } finally { //close connection ,stmt and resultset here  try { con.close(); } catch(SQLException se) { /*can\u0026#39;t do anything */ } try { stmt.close(); } catch(SQLException se) { /*can\u0026#39;t do anything */ } try { rs.close(); } catch(SQLException se) { /*can\u0026#39;t do anything */ } session.disconnect(); } } public static void makeTunnelSSH(){ String user = \u0026#34;Имя пользователя, который user из \u0026gt;ssh user@host\u0026#34;; String password = \u0026#34;Пароль этого пользователя\u0026#34;; String host = \u0026#34;host из \u0026gt;ssh user@host. Белый ip крч\u0026#34;; int port=22; //порт для ssh соединения с host  try { JSch jsch = new JSch(); session = jsch.getSession(user, host, port); lport = 1234; rhost = \u0026#34;localhost\u0026#34;; rport = 3306; session.setPassword(password); session.setConfig(\u0026#34;StrictHostKeyChecking\u0026#34;, \u0026#34;no\u0026#34;); System.out.println(\u0026#34;Establishing Connection...\u0026#34;); session.connect(); int assinged_port=session.setPortForwardingL(lport, rhost, rport); System.out.println(\u0026#34;localhost:\u0026#34;+assinged_port+\u0026#34; -\u0026gt; \u0026#34;+rhost+\u0026#34;:\u0026#34;+rport); } catch(Exception e){System.err.print(e);} } } Компилируем её:\njavac -encoding utf-8 -cp .:./lib/mysql-connector-java-x.x.xx.jar:./lib/jsch-0.1.55.jar UpdateMySqlDatabase.java Запускаем:\njava -cp .:./lib/mysql-connector-java-x.x.xx.jar:./lib/jsch-0.1.55.jar UpdateMySqlDatabase Если всё правильно сделать, то вывод должен быть тот же:\nTotal number of books in the table : 2\nЗабавно, что пока запущена эта программа, то туннель создан и существовать, пока работает программа. Если закомментировать строку session.disconnect();\nто программа не завершит свою работу, а значит туннель будет по-прежнему открыт\nШаг третий: Hibernate pizza time Что за hibernate? Есть СУБД и java. Надо это как-то соединить. JDBC - это как раз и делает:\njava \u0026lt;-\u0026gt; JDBC \u0026lt;-\u0026gt; СУБД\nНо многим кажется, что это сложно. Придумали hibernate:\njava \u0026lt;-\u0026gt; hibernate \u0026lt;-\u0026gt; JDBC \u0026lt;-\u0026gt; СУБД\nА на самом деле вот так:\njava \u0026lt;-\u0026gt; hibernate \u0026lt;-\u0026gt; JDBC и ещё много всего \u0026lt;-\u0026gt; СУБД\nТ. е. hibernate использует ещё и то, что реализует JDBC (т. е. mysql-connector), для подключения к БД. Он даёт возможность использовать СУБД \u0026ldquo;без знания\u0026rdquo; SQL, всю эту работу (составление запросов, подключение к БД, проведение транзакций, удаление и создание записей в БД) hiberbate берёт на себя, но за счёт снижения (достаточно сильно) скорости работы программы. Нам же остаётся просто работать с объектами как раньше. Hibernate должен упрощать работу с БД, но это не значит, что можно не знать SQL язык. Также это не значит, что можно не уметь работать с JDBC.\nНо между hibernate и JDBC большая разница.\nORM - технология (шаблон) проектирования, которая(ый) связывает БД с ООП\nJPA - это стандарт для ORM\nJDBC - это стандарт для доступа к БД\nmysql-connector - реализует JDBC\nhibernate - реализует JPA\nНадеюсь, теперь стало лучше с пониманием, что за hibernate. Теперь к делу.\nСкачаем всё необходимое. Заходим на hibernate.org/orm/ и скачиваем (жмякаем на большую синюю кнопку Download Zip archive). В моём случае hibernate-release-5.4.28.Final.zip. Весит, конечно, он изрядно, но благо нам оттуда нужны лишь файлы из /hibernate-release-x.x.xx.Final/lib/required/\nУ меня были такие:\n antlr-2.7.7.jar FastInfoset-1.2.15.jar istack-commons-runtime-3.0.7.jar javax.activation-api-1.2.0.jar jaxb-api-2.3.1.jar jaxb-runtime-2.3.1.jar stax-ex-1.8.jar txw2-2.3.1.jar byte-buddy-1.10.17.jar classmate-1.5.1.jar dom4j-2.1.3.jar hibernate-commons-annotations-5.1.2.Final.jar jandex-2.2.3.Final.jar javassist-3.27.0-GA.jar javax.persistence-api-2.2.jar jboss-logging-3.4.1.Final.jar jboss-transaction-api_1.2_spec-1.1.1.Final.jar hibernate-core-5.4.28.Final.jar  Много тут всякого\u0026hellip; Почти 15 МБ! Но это ведь целый framework, чего вы хотели?\nЕщё на момент создания гайда использую mysql-connector-java-8.0.23.jar\nПродолжаем:\nЗадача запустить какой-нибудь код с использованием hibernate. Без IDE\u0026hellip; Попробуем.\nЗакинем ВСЕ эти jar-файлики в ./lib/\nПервым делом создадим тестовую БД studtable, таблицу student и пользователя suser:\nCREATEDATABASEstudtable;usestudtable;CREATETABLE`student`(`id`int(11)NOTNULLAUTO_INCREMENT,`first_name`varchar(45)DEFAULTNULL,`last_name`varchar(45)DEFAULTNULL,`email`varchar(45)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBAUTO_INCREMENT=1DEFAULTCHARSET=latin1;CREATEUSER\u0026#39;suser\u0026#39;IDENTIFIEDBY\u0026#39;suser123?Password\u0026#39;;GRANTALLPRIVILEGESONstudtable.*TO\u0026#39;suser\u0026#39;;FLUSHPRIVILEGES;exit;Теперь создадим в директории ./ файлик hibernate.cfg.xml с содержимым:\n\u0026lt;!DOCTYPE hibernate-configuration PUBLIC \u0026#34;-//Hibernate/Hibernate Configuration DTD 3.0//EN\u0026#34; \u0026#34;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\u0026#34;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- JDBC Database connection settings --\u0026gt; \u0026lt;property name=\u0026#34;connection.driver_class\u0026#34;\u0026gt;com.mysql.cj.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;connection.url\u0026#34;\u0026gt;jdbc:mysql://[ip]:3306/studtable\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;connection.username\u0026#34;\u0026gt;suser\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;connection.password\u0026#34;\u0026gt;suser123?Password\u0026lt;/property\u0026gt; \u0026lt;!-- JDBC connection pool settings ... using built-in test pool --\u0026gt; \u0026lt;property name=\u0026#34;connection.pool_size\u0026#34;\u0026gt;1\u0026lt;/property\u0026gt; \u0026lt;!-- Select our SQL dialect --\u0026gt; \u0026lt;property name=\u0026#34;dialect\u0026#34;\u0026gt;org.hibernate.dialect.MySQLDialect\u0026lt;/property\u0026gt; \u0026lt;!-- Echo the SQL to stdout --\u0026gt; \u0026lt;property name=\u0026#34;show_sql\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- Set the current session context --\u0026gt; \u0026lt;property name=\u0026#34;current_session_context_class\u0026#34;\u0026gt;thread\u0026lt;/property\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt; Чтобы hibernate указать, что объект должен соответствовать записи в БД, то:\n Создаём специальный xml файл. Но это устарело и не будем рассматривать Или аннорируем код (то, что начинается с символа @) Рассмотрим аннотацию на примере Student.java:  import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; //Entity=Объект соответствует записи в таблице // Table=название этой таблице @Entity @Table(name=\u0026#34;student\u0026#34;) public class Student { //Id=что это \u0026#34;primary key\u0026#34; объекта  //GeneratedValue=способ генерации этого ключа  //strategy=GenerationType.IDENTITY значит также как и в БД. Во время создания таблицы мы указали AUTO_INCREMENT, значит так и будет  //Column(name=\u0026#34;id\u0026#34;) значит, что это поле соответствует колонке (полю) id \t@Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\u0026#34;id\u0026#34;) private int id; //Column(name=\u0026#34;first_name\u0026#34;) значит, что это поле соответствует колонке (полю) first_name \t@Column(name=\u0026#34;first_name\u0026#34;) private String firstName; //Column(name=\u0026#34;last_name\u0026#34;) значит, что это поле соответствует колонке (полю) last_name \t@Column(name=\u0026#34;last_name\u0026#34;) private String lastName; //Column(name=\u0026#34;email\u0026#34;) значит, что это поле соответствует колонке (полю) email \t@Column(name=\u0026#34;email\u0026#34;) private String email; public Student() {} public Student(String firstName, String lastName, String email) { this.firstName = firstName; this.lastName = lastName; this.email = email; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } @Override public String toString() { return \u0026#34;Student [id=\u0026#34; + id + \u0026#34;, firstName=\u0026#34; + firstName + \u0026#34;, lastName=\u0026#34; + lastName + \u0026#34;, email=\u0026#34; + email + \u0026#34;]\u0026#34;; } } И сам класс CreateStudent.java с подключением:\nimport org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; public class CreateStudent { public static void main(String[] args) { // create session factory \tSessionFactory factory = new Configuration() .configure(\u0026#34;hibernate.cfg.xml\u0026#34;) .addAnnotatedClass(Student.class) .buildSessionFactory(); // create session \tSession session = factory.getCurrentSession(); try {\t// create a student object \tSystem.out.println(\u0026#34;Creating new student object...\u0026#34;); // Когда создавали factory, то указали addAnnotatedClass(Student.class). Обратите на это внимание, когда дойдёте до session.save(tempStudent) \tStudent tempStudent = new Student(\u0026#34;Paul\u0026#34;, \u0026#34;Wall\u0026#34;, \u0026#34;blblbl@horse.hole\u0026#34;); // start a transaction \tsession.beginTransaction(); // save the student object \tSystem.out.println(\u0026#34;Saving the student...\u0026#34;); session.save(tempStudent); // commit transaction \tsession.getTransaction().commit(); System.out.println(\u0026#34;Done!\u0026#34;); } finally { factory.close(); } } } Попробуем скомпилировать:\n\u0026gt; javac -encoding utf-8 -cp .:./lib/mysql-connector-java-8.0.23.jar:./lib/antlr-2.7.7.jar:./lib/FastInfoset-1.2.15.jar:./lib/istack-commons-runtime-3.0.7.jar:./lib/javax.activation-api-1.2.0.jar:./lib/jaxb-api-2.3.1.jar:./lib/jaxb-runtime-2.3.1.jar:./lib/stax-ex-1.8.jar:./lib/txw2-2.3.1.jar:./lib/byte-buddy-1.10.17.jar:./lib/classmate-1.5.1.jar:./lib/dom4j-2.1.3.jar:./lib/hibernate-commons-annotations-5.1.2.Final.jar:./lib/jandex-2.2.3.Final.jar:./lib/javassist-3.27.0-GA.jar:./lib/javax.persistence-api-2.2.jar:./lib/jboss-logging-3.4.1.Final.jar:./lib/jboss-transaction-api_1.2_spec-1.1.1.Final.jar:./lib/hibernate-core-5.4.28.Final.jar CreateStudent.java Фуф, сколько символов. Теперь пробуем запустить:\n\u0026gt; java -cp .:./lib/mysql-connector-java-8.0.23.jar:./lib/antlr-2.7.7.jar:./lib/FastInfoset-1.2.15.jar:./lib/istack-commons-runtime-3.0.7.jar:./lib/javax.activation-api-1.2.0.jar:./lib/jaxb-api-2.3.1.jar:./lib/jaxb-runtime-2.3.1.jar:./lib/stax-ex-1.8.jar:./lib/txw2-2.3.1.jar:./lib/byte-buddy-1.10.17.jar:./lib/classmate-1.5.1.jar:./lib/dom4j-2.1.3.jar:./lib/hibernate-commons-annotations-5.1.2.Final.jar:./lib/jandex-2.2.3.Final.jar:./lib/javassist-3.27.0-GA.jar:./lib/javax.persistence-api-2.2.jar:./lib/jboss-logging-3.4.1.Final.jar:./lib/jboss-transaction-api_1.2_spec-1.1.1.Final.jar:./lib/hibernate-core-5.4.28.Final.jar CreateStudent Если не нужен весь этот мусор в консоли, то в файле hibernate.cfg.xml меняем строку \u0026lt;property name=\u0026quot;show_sql\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; на \u0026lt;property name=\u0026quot;show_sql\u0026quot;\u0026gt;false\u0026lt;/property\u0026gt;\nТеперь проверьте, что запись в БД успешно создалась (ну или ждите пока пройдёт полнолуние)\nМы рассмотрели как установить mySQL (на Linux), как подключить ваш java проект к СУБД, как учесть то, что у вас может быть SQL сервер запущен на настоящем сервере, как создать SSH туннель с помощью стандартных средств и с помощью java, как подключить к вашему проекту hibernate. Много короче рассмотрели. Теперь, можно пользоваться java с SQL с помощью hibernate без IDE (осталось только выучить java, SQL, JDBC и hibernate). Хотя, если вы знаете, как работать в вашей рабочей среде, то сможете спокойно применить этот гайд и к вашей IDE.\n","permalink":"https://the220th.github.io/guides/coding/java-sql/","tags":null,"title":"Подключение SQL в Java без IDE"}]